<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; object-src 'none'"><meta name="generator" content="Some custom Common Lisp"><meta name="description" content="Latest posts on Fanael's random ruminations"><link rel="alternate" href="/feed.xml" title="Fanael's random ruminations" type="application/rss+xml"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>Fanael's random ruminations</title></head><body><a id="skip-nav" href="#main">Skip to main content</a><header id="mainheader">Fanael's random ruminations</header><nav aria-label="Primary"><ul id="navmenu"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main id="main"><header><h1>Latest articles</h1></header><article id="stockfish-on-windows-98"><header><h2><a href="/stockfish-on-windows-98.html">Current Stockfish on Windows 98?!</a></h2><p>Published on the <time datetime="2020-09-24">24th of September 2020</time></p><p>Topics: <a href="/archives/topic-retro.html">retro</a>, <a href="/archives/topic-windows-9x.html">windows-9x</a></p></header><p>A few weeks ago I had this weird idea: would it be possible to make an up-to-date version of <a href="https://stockfishchess.org/">Stockfish</a> run on Windows 98? There's an immediate problem with that: Stockfish is written in C++17, which is the still-current, at the time of writing, revision of the C++ language; surely there are no C++17 capable compilers that can still target something as old as Windows 98?</p><div class="note"><p>Disclaimer: in this article, by "Windows 98" I mean Windows 98 second edition with the main files of the <a href="https://www.techtalk.cc/viewtopic.php?t=65">unofficial service pack</a> installed, which is a convenient bundle of official and unofficial patches. I don't care about Windows 98 first edition, nor the second edition <em>without</em> those updates installed. Note that <a href="https://sourceforge.net/projects/kernelex/">KernelEx</a> is <em>not needed</em>.</p><p>I'm fully aware this has no practical value, but it was a fun thing to do.</p></div><p>As it turns out, the GNU toolchain, comprised of <a href="https://www.gnu.org/software/binutils/">GNU binutils</a> and <a href="https://gcc.gnu.org/">GCC, the GNU Compiler Collection</a>, doesn't particularly care about all the different Windows versions and will happily output a binary that works on any 32-bit Windows.</p><p>The compiler itself, assembler and linker are only a part of a functional compiler package, though. There's one part we're missing: the runtime library, which provides the system-specific program initialization code that runs before the <code>main</code> function. Since we're using GCC, the obvious choice is the <a href="https://sourceforge.net/projects/mingw-w64/">mingw-w64</a> runtime. It also provides Windows API headers, bindings to (pretty much all the extant versions of) the Microsoft Visual C++ standard C library, and a POSIX threading API compatibility layer, <cite class="program-name">winpthreads</cite>, which is required for C++ standard threading library support in GCC.</p><p>Fortunately for us, a minimal Windows program compiled with GCC with mingw-w64 appears to work fine when executed under Windows 98:</p><pre class="codeblock" data-code-language="C++"><code><span class="c-c">#</span><span class="c-c">include</span> <span class="c-c">&lt;windows.h&gt;</span><span class="c-c">
</span>
<span class="c-k">int</span> WINAPI WinMain(HINSTANCE, HINSTANCE, <span class="c-k">char</span>*, <span class="c-k">int</span>)
{
    MessageBoxA(<span class="c-k">nullptr</span>, <span class="c-s">"</span><span class="c-s">Hello world!</span><span class="c-s">"</span>, <span class="c-s">"</span><span class="c-s">A test</span><span class="c-s">"</span>, MB_OK);
    <span class="c-k">return</span> <span class="c-m">0</span>;
}
</code></pre><p>So maybe all we have to do is to compile Stockfish and it will just work on Windows 98…?</p><a class="read-full" href="/stockfish-on-windows-98.html" aria-label="Read the full article: Current Stockfish on Windows 98?!">Read the full article…</a></article><article id="is-x86-risc-internally"><header><h2><a href="/is-x86-risc-internally.html">The legend of "x86 CPUs decode instructions into RISC form internally"</a></h2><p>Published on the <time datetime="2020-06-30">30th of June 2020</time></p><p>Topics: <a href="/archives/topic-microarchitectural-musings.html">microarchitectural-musings</a>, <a href="/archives/topic-mythbusting.html">mythbusting</a></p></header><p>There is a widespread idea that modern high-performance x86 processors work by decoding the "complex" x86 instructions into "simple" RISC-like instructions that the rest of the pipeline then operates on. But how close is this idea to how the processors <em>actually</em> work internally?</p><p>To answer this question, let's analyze how different x86 processors, ranging from the first "modern" Intel microarchitecture, P6, to their current designs, handle the following simple loop (the code is 32-bit just to allow us to discuss very old x86 processors):</p><pre class="codeblock" data-code-language="x86 assembly"><code>.loop:
    add [edx], eax
    add edx, 4
    sub eax, 1
    jnz .loop
</code></pre><a class="read-full" href="/is-x86-risc-internally.html" aria-label="Read the full article: The legend of &quot;x86 CPUs decode instructions into RISC form internally&quot;">Read the full article…</a></article><article id="blue-ridge-errata-1"><header><h2><a href="/blue-ridge-errata-1.html">Blue Ridge errata #1: root pointers during evacuation</a></h2><p>Published on the <time datetime="2020-02-08">8th of February 2020</time></p><p>Topics: <a href="/archives/topic-garbage-collection.html">garbage-collection</a></p></header><p>While trying to implement concurrent evacuation I've found out that there is a serious problem with <a href="/incremental-low-pause-gc.html">my simple incremental low-pause garbage collector</a> design. Implementing the <a href="/incremental-low-pause-gc.html#phases">phase ordering</a> exactly as specified <strong>would corrupt the root set</strong>, resulting in not very fun to debug crashes, even with extensive heap verification and lots of assertions everywhere. Why? Let's go through the pertinent assumptions, and the way they interact, carefully, and find a solution.</p><a class="read-full" href="/blue-ridge-errata-1.html" aria-label="Read the full article: Blue Ridge errata #1: root pointers during evacuation">Read the full article…</a></article><article id="breaking-empty-base-optimization"><header><h2><a href="/breaking-empty-base-optimization.html">How to: accidentally break empty base optimization</a></h2><p>Published on the <time datetime="2019-12-20">20th of December 2019</time></p><p>Topics: <a href="/archives/topic-i-hate-c++.html">i-hate-c++</a></p></header><p>A reasonably common idiom in C++ code is the use of the following or similar class to inhibit move and copy operations, to avoid having to repeat the four <code>delete</code>d functions in every class: </p><pre class="codeblock" data-code-language="C++"><code><span class="c-k">class</span> noncopyable {
<span class="c-k">public</span>:
    noncopyable(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
    noncopyable(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
    noncopyable&amp; <span class="c-k">operator</span>=(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
    noncopyable&amp; <span class="c-k">operator</span>=(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
<span class="c-k">protected</span>:
    noncopyable() = <span class="c-k">default</span>;
    ~noncopyable() = <span class="c-k">default</span>;
};
</code></pre><aside><p>I'm personally not a huge fan of the <code>noncopyable</code> name, because it describes <em>how</em> instead of <em>why</em>, but that's neither here nor there.</p></aside><p>The <code>noncopyable</code> class can be mixed in using inheritance, like so:</p><pre class="codeblock" data-code-language="C++"><code><span class="c-k">class</span> foo : <span class="c-k">private</span> noncopyable {
    <span class="c-c">// …
</span>};
</code></pre><p>So far, so good, but there's more to it than meets the eye.</p><a class="read-full" href="/breaking-empty-base-optimization.html" aria-label="Read the full article: How to: accidentally break empty base optimization">Read the full article…</a></article><article id="blue-ridge-status-update-dec-2019"><header><h2><a href="/blue-ridge-status-update-dec-2019.html">Blue Ridge status update: December 2019</a></h2><p>Published on the <time datetime="2019-12-08">8th of December 2019</time></p><p>Topics: <a href="/archives/topic-garbage-collection.html">garbage-collection</a></p></header><p>Just a "quick" update on the development status of <a href="/incremental-low-pause-gc.html">my low-pause incremental garbage collector</a> (code name <dfn>Blue Ridge</dfn>): it's progressing rather nicely, considering how little motivation my clinically depressed self is able to muster up most days.</p><aside><p>No points for guessing where the code name comes from.</p></aside><p>The garbage collector as currently implemented, in just above 2 thousand lines of code, is already <em>working</em>, that is, it correctly allocates memory and collects garbage, <em>even under address and undefined behavior sanitizers</em>, though it's limited to stop-the-world operation at the moment. This is merely a pragmatic decision on what order to do things in: I'd rather have heap verifiers implemented and tested before diving into incrementality, as catching any potential heap corruptions or invariant violations right away is much preferable to trying to divine the cause of a crash from a core dump.</p><p>That being said, most of the hard work for supporting incremental collections has already been done. Most of the collector's code is written in a way that makes incremental work easy enough, it just happens to not be used in that way yet.</p><p>Performance appears to be fine so far. Pure allocation rate of object that die quickly is limited by how fast the CPU is able to write object data to memory, like in any good moving GC, as the hot path of allocation consists of just advancing a pointer. Collection time is dominated by marking, as one could expect. Throughput, measured by taking the wall-clock time of a program that allocates a linked list of 10 million conses then throws it away, repeating 500 times, is not bad either, being within the same order of magnitude as <a href="https://wiki.openjdk.java.net/display/shenandoah/Main">HotSpot's Shenandoah collector</a> in its passive (stop-the-world only) mode, and <em>beating handily</em> its Parallel and G1 collectors with all four collectors limited to a 1 GB heap, which again, is not unexpected: this is not a very good workload+heap size combination for generational collectors, as they're forced to prematurely tenure conses, which then results in a significant number of painful major collections, while Blue Ridge and Shenandoah aren't affected due to their non-generational nature.</p><p>Blue Ridge in its current state also features <dfn>policies</dfn>, switchable at runtime, that are informed whenever interesting events happen, such as a new region being allocated or the current phase being changed, and that in turn decide whether or not start a cycle, and if so what kind — incremental or stop-the-world — and what regions should belong to the collection set. It is through this mechanism that the aforementioned 1 GB heap limit has been implemented, as Blue Ridge's heap is normally discontinuous, dynamically resizable in either direction and theoretically unlimited.</p><p>All things considered, the development of my garbage collector is progressing well, if slowly due to circumstances beyond my control. I hope I'll be able to have a functionally complete version soon, because that's where the real fun begins: playing around with all the knobs the get the lowest latency, lowest footprint and highest throughput possible.</p><a class="read-full" href="/blue-ridge-status-update-dec-2019.html" aria-label="Read the full article: Blue Ridge status update: December 2019">Read the full article…</a></article></main><nav aria-label="Chronological, secondary"><ul id="prevnext"><li class="top"><a href="#skip-nav">↑ Top ↑</a></li><li class="prev"></li><li><a href="/archives/">Blog archives</a></li><li class="next"></li></ul></nav><footer><ul id="footerstuff"><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019-2021 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>