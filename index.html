<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="generator" content="Some custom Common Lisp"><meta name="description" content="Latest posts on Fanael's random ruminations"><script defer src="/static/fixes.js"></script><link rel="alternate" href="/feed.xml" title="Fanael's random ruminations" type="application/rss+xml"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>Fanael's random ruminations</title></head><body><header id="top-header"><a id="skip-nav" class="at-only" href="#main">Skip to main content</a><span>Fanael's random ruminations</span></header><nav aria-label="Primary"><ul id="top-nav"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main id="main"><header><h1>Latest articles</h1></header><article id="you-can-embrace-extend-extinguish-free-software"><header><h2><a href="/you-can-embrace-extend-extinguish-free-software.html">Yes, you can embrace, extend, extinguish free software</a></h2><p>Published on the <time datetime="2022-09-22">22nd of September 2022</time></p></header><p>KHTML</p><a class="read-full" href="/you-can-embrace-extend-extinguish-free-software.html" aria-label="Read the full article: Yes, you can embrace, extend, extinguish free software">Read the full article…</a></article><article id="dotnet-object-init-slow"><header><h2><a href="/dotnet-object-init-slow.html">.NET object initialization is surprisingly slow</a></h2><p>Published on the <time datetime="2022-08-18">18th of August 2022</time></p><p>Topics: <a href="/archives/topic-java.html">java</a>, <a href="/archives/topic-dot-net.html">dot-net</a>, <a href="/archives/topic-garbage-collection.html">garbage-collection</a></p></header><p>…sometimes, at least. When compared to Java under OpenJDK.</p><p>I was performing some experiments with various ways of implementing <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">persistent</a> random-access sequences. At one point, after implementing some of them in Java, I had the brilliant idea to try and implement some of them in C# as well and see how performance compares.</p><p>Unfortunately, this comparison was not very favorable towards C#: it consistently performed around 4-6× slower, <em>four to six times</em>, than the <em>same</em> data structure in Java. That was certainly… <em>not</em> what I expected. I was expecting the performance to be very close, if not C#-favored. After all, the Common Language Runtime supports value types, whereas the Java Virtual Machine at the moment does not, and some of the data structures I tested can benefit from reduced indirection.</p><p>Profiling revealed that the hottest functions were those that created new objects. While this does make sense, as persistent data structures using path copying <em>do</em> create many objects, spending north of 80% wall clock time on <em>just</em> allocating new objects, instead of on actual logic, is certainly a lot.</p><p>The next step I took to understand why those functions take so much time was, naturally, looking at the generated code. The differences were quite stark, and explained the performance gap almost immediately, so why don't we take a look?</p><a class="read-full" href="/dotnet-object-init-slow.html" aria-label="Read the full article: .NET object initialization is surprisingly slow">Read the full article…</a></article><article id="dependency-breaking-xor-p6"><header><h2><a href="/dependency-breaking-xor-p6.html">Dependency-breaking zeroing XOR in P6</a></h2><p>Published on the <time datetime="2021-04-08">8th of April 2021</time></p><p>Topics: <a href="/archives/topic-microarchitecture-archeology.html">microarchitecture-archeology</a>, <a href="/archives/topic-mythbusting.html">mythbusting</a></p></header><p>In x86 assembly language, a common idiom for setting the value of a register to 0 is to use the exclusive-or instruction with both operands being the same register, such as <code>xor eax, eax</code>. It was originally intended as a size optimization: the obvious <code>mov eax, 0</code> is encoded as <em>five</em> bytes, of which four are used to store the constant 0, while the exclusive-or solution needs merely <em>two</em>, and is equally as fast, so it quickly became widespread.</p><p>By the time the P6 microarchitecture was being designed, the <code>xor</code> zeroing idiom was already nigh-universal in compiler output and hand-written assembly alike, so it was specifically recognized as a zeroing idiom for the purpose of avoiding partial register stalls in code such as this:</p><pre class="code-block"><span class="cx-language">x86 assembly</span>
<code class="cx-numbered"><span class="cx-ln"></span><span>    <span class="c-nf">xor</span> <span class="c-nb">eax</span>, <span class="c-nb">eax</span>
</span><span class="cx-ln"></span><span>    <span class="c-nf">mov</span> <span class="c-nb">al</span>, [<span class="c-nb">ecx</span>]
</span><span class="cx-ln"></span><span>    <span class="c-c">; use eax</span>
</span></code></pre><p>In code tuned for the original Pentium or earlier processors, this was the usual way of zero-extending an 8-bit (or 16-bit with <code>ax</code> instead of <code>al</code>) value into the full 32-bit register, as the <code>movzx</code> instruction was slower. P6, starting from the very first Pentium Pro, recognized that after a <code>xor</code> of a register with itself, the register held 0, which avoided the partial register stall that would otherwise occur when modifying a low part of a register followed by operations on the full 32 bits.</p><p>Unfortunately, the Pentium Pro as originally designed was too ambitious to be realized using then-available lithography technology without making the chip too big — and thus too prone to manufacturing defects — so some features had to go. Segment register renaming and beefier secondary decoders were some of the notable victims of that process.</p><p>I assume that the ability to recognize that the exclusive-or zeroing idiom doesn't <em>really</em> depend on the previous value of a register, so that it can be dispatched immediately without waiting for the old value — thus breaking the dependency chain — met the same fate; the Pentium Pro shipped without it.</p><p>Some of the cut features were introduced in later models: segment register renaming, for example, was added back in the Pentium II. Maybe dependency-breaking zeroing XOR was added in later P6 models too? After all, it seems such a simple yet important thing, and indeed, I remember seeing people claim that's the case in some old forum posts and mailing list messages. On the other hand, some sources, such as <a href="https://www.agner.org/optimize/">Agner Fog's optimization manuals</a> say that not only it was never present in any of the P6 processors, it was also missing in Pentium M.</p><p>Whatever the case may be, there's only one way to make sure: test it!</p><a class="read-full" href="/dependency-breaking-xor-p6.html" aria-label="Read the full article: Dependency-breaking zeroing XOR in P6">Read the full article…</a></article><article id="blog-update"><header><h2><a href="/blog-update.html">Blog update</a></h2><p>Published on the <time datetime="2021-04-01">1st of April 2021</time></p><p>Topics: <a href="/archives/topic-meta.html">meta</a></p></header><p>In the past few days I've made some changes — some immediately noticeable, some less so — to the blog. Why not have a look at them?</p><div class="sidenote" role="note"><p>I've been writing another, more substantial and much larger article for quite some time. I initially wanted to publish it in December, then January, then March, but getting it into a shape I'm comfortable with takes much more time and effort than I anticipated. Sorry about that.</p></div><p>The big, immediately noticeable change is that the <a href="/">main page</a> is no longer a copy of the latest article. I've changed it to the tried and true format of using the introductory section of the last several articles, where "several" is defined here as five.</p><p>With that change, the need for displaying an article permalink in the header vanished: since pages aren't getting copied anymore, there's no need for an explicit, unambiguous, canonical link to an article. The address the browser displays when you read an article <em>is</em> now the canonical link, putting one in the article header as well would just be superfluous.</p><p>While the other changes are minor and not as readily — if at all — noticeable to most readers, they still warrant coverage, in their own subsections.</p><a class="read-full" href="/blog-update.html" aria-label="Read the full article: Blog update">Read the full article…</a></article><article id="stockfish-on-windows-98"><header><h2><a href="/stockfish-on-windows-98.html">Current Stockfish on Windows 98?!</a></h2><p>Published on the <time datetime="2020-09-24">24th of September 2020</time></p><p>Topics: <a href="/archives/topic-retro.html">retro</a>, <a href="/archives/topic-windows-9x.html">windows-9x</a></p></header><p>A few weeks ago I had this weird idea: would it be possible to make an up-to-date version of <a href="https://stockfishchess.org/">Stockfish</a> run on Windows 98? There's an immediate problem with that: Stockfish is written in C++17, which is the still-current, at the time of writing, revision of the C++ language; surely there are no C++17 capable compilers that can still target something as old as Windows 98?</p><div class="info"><p>Disclaimer: in this article, by "Windows 98" I mean Windows 98 second edition with the main files of the <a href="https://www.techtalk.cc/viewtopic.php?t=65">unofficial service pack</a> installed, which is a convenient bundle of official and unofficial patches. I don't care about Windows 98 first edition, nor the second edition <em>without</em> those updates installed. Note that <a href="https://sourceforge.net/projects/kernelex/">KernelEx</a> is <em>not needed</em>.</p><p>I'm fully aware this has no practical value, but it was a fun thing to do.</p></div><p>As it turns out, the GNU toolchain, comprised of <a href="https://www.gnu.org/software/binutils/">GNU binutils</a> and <a href="https://gcc.gnu.org/">GCC, the GNU Compiler Collection</a>, doesn't particularly care about all the different Windows versions and will happily output a binary that works on any 32-bit Windows.</p><p>The compiler itself, assembler and linker are only a part of a functional compiler package, though. There's one part we're missing: the runtime library, which provides the system-specific program initialization code that runs before the <code>main</code> function. Since we're using GCC, the obvious choice is the <a href="https://sourceforge.net/projects/mingw-w64/">mingw-w64</a> runtime. It also provides Windows API headers, bindings to (pretty much all the extant versions of) the Microsoft Visual C++ standard C library, and a POSIX threading API compatibility layer, <cite class="program-name">winpthreads</cite>, which is required for C++ standard threading library support in GCC.</p><p>Fortunately for us, a minimal Windows program compiled with GCC with mingw-w64 appears to work fine when executed under Windows 98:</p><pre class="code-block"><span class="cx-language">C++</span>
<code class="cx-numbered"><span class="cx-ln"></span><span><span class="c-c">#include</span> <span class="c-c">&lt;windows.h&gt;
</span></span><span class="cx-ln"></span><span>
</span><span class="cx-ln"></span><span><span class="c-k">int</span> WINAPI <span class="c-nf">WinMain</span>(HINSTANCE, HINSTANCE, <span class="c-k">char</span>*, <span class="c-k">int</span>)
</span><span class="cx-ln"></span><span>{
</span><span class="cx-ln"></span><span>    MessageBoxA(<span class="c-k">nullptr</span>, <span class="c-s">"Hello world!"</span>, <span class="c-s">"A test"</span>, MB_OK);
</span><span class="cx-ln"></span><span>    <span class="c-k">return</span> <span class="c-m">0</span>;
</span><span class="cx-ln"></span><span>}
</span></code></pre><p>So maybe all we have to do is to compile Stockfish and it will just work on Windows 98…?</p><a class="read-full" href="/stockfish-on-windows-98.html" aria-label="Read the full article: Current Stockfish on Windows 98?!">Read the full article…</a></article></main><nav aria-label="Chronological, secondary"><ul id="order-nav"><li class="top"><a href="#skip-nav"><span aria-hidden="true">↑ </span>Top<span aria-hidden="true"> ↑</span></a></li><li class="prev"></li><li><a href="/archives/">Blog archives</a></li><li class="next"></li></ul></nav><footer><ul id="footer"><li><a href="/pages/offline-mode.html">Offline mode</a></li><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019-2022 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>