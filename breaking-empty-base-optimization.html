<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Security-Policy" content="default-src 'self'"><meta name="generator" content="Some custom Common Lisp"><meta name="description" content="Empty base optimization in C++ is very brittle, how (not) to break it?"><link rel="canonical" href="/breaking-empty-base-optimization.html"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>How to: accidentally break empty base optimization - Fanael's random ruminations</title></head><body><header id="mainheader">Fanael's random ruminations</header><nav><ul id="navmenu"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main><article id="root-section"><header><h1><a class="section-header-link" href="#root-section">§</a>How to: accidentally break empty base optimization</h1><p class="publishdate">Published on the <time datetime="2019-12-20">20th of December 2019</time></p><p class="article-topics">Topics: <a href="/archives/topic-i-hate-c++.html">i-hate-c++</a></p></header><p>A reasonably common idiom in C++ code is the use of the following or similar class to inhibit move and copy operations, to avoid having to repeat the four <code>delete</code>d functions in every class: </p><pre class="codeblock" data-code-language="C++"><code><span class="c-k">class</span> noncopyable {
<span class="c-k">public</span>:
    noncopyable(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
    noncopyable(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
    noncopyable&amp; <span class="c-k">operator</span>=(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
    noncopyable&amp; <span class="c-k">operator</span>=(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
<span class="c-k">protected</span>:
    noncopyable() = <span class="c-k">default</span>;
    ~noncopyable() = <span class="c-k">default</span>;
};
</code></pre><aside><p>I'm personally not a huge fan of the <code>noncopyable</code> name, because it describes <em>how</em> instead of <em>why</em>, but that's neither here nor there.</p></aside><p>The <code>noncopyable</code> class can be mixed in using inheritance, like so:</p><pre class="codeblock" data-code-language="C++"><code><span class="c-k">class</span> foo : <span class="c-k">private</span> noncopyable {
    <span class="c-c">// …
</span>};
</code></pre><p>So far, so good, but there's more to it than meets the eye.</p><nav class="toc"><ol><li><a href="#the-problem">The problem</a></li><li><a href="#the-temporary-workaround">The (temporary) workaround</a></li><li><a href="#the-future-solution">The (future) solution</a></li></ol></nav><section id="the-problem"><h2><a class="section-header-link" href="#the-problem">§</a>The problem</h2><p>This definition of <code>noncopyable</code> relies heavily on <dfn>empty base optimization</dfn>: normally, every object in C++ has size of at least one byte and (equivalently) a unique address, but in certain conditions this requirement can be relaxed for <em>empty base subobjects</em>:</p><pre class="codeblock" data-code-language="C++"><code><span class="c-k">class</span> foo : <span class="c-k">private</span> noncopyable {
    <span class="c-k">int</span> x;
};

<span class="c-c">// Always true.
</span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(noncopyable) &gt;= <span class="c-m">1</span>);
<span class="c-c">// True on every implementation that doesn't add gratuitous padding after
</span><span class="c-c">// the last member.
</span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(foo) == <span class="c-k">sizeof</span>(<span class="c-k">int</span>));
</code></pre><p>There is a problem, however. <strong>Empty base optimization can be applied only if the base class type is not the type, or a possibly-indirect base type of that type, of the first member</strong>, as the two subobjects are explicitly required to have distinct addresses. From this requirement it follows that the empty base optimization is <strong>prohibited</strong> in the following code:</p><pre class="codeblock" data-code-language="C++"><code><span class="c-k">class</span> foo : <span class="c-k">private</span> noncopyable {
    <span class="c-k">int</span> x;
};

<span class="c-k">class</span> bar : <span class="c-k">private</span> noncopyable {
    foo x;
};

<span class="c-c">// Always true (!), as the noncopyable base subobject of foo and
</span><span class="c-c">// the noncopyable base subobject of bar are required to have distinct
</span><span class="c-c">// addresses.
</span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(bar) &gt; <span class="c-k">sizeof</span>(foo));
</code></pre><p>Now, if non-copyability of <code>foo</code> is a part of its public API, one could argue that the solution is to just not declare <code>bar</code> as non-copyable; but if it's merely an implementation detail, not explicitly making <code>bar</code> non-copyable couples it too tightly to the implementation of <code>foo</code> and as such should be, in my opinion at least, avoided.</p></section><section id="the-temporary-workaround"><h2><a class="section-header-link" href="#the-temporary-workaround">§</a>The (temporary) workaround</h2><p>There are ways to work around this problem. One such way is to use a preprocessor macro instead of mixing in a base class, but the C++ preprocessor is absolutely awful, so I'd rather not go this route.</p><p>The solution I personally prefer exploits the fact that one of the requirements for the empty base optimization to apply is that the base class is not of <em>the same type</em> as the first non-static data member or one of its bases. What if there was a way to create similar types that are completely distinct? There is, that's precisely what C++ templates are for:</p><pre class="codeblock" data-code-language="C++"><code><span class="c-k">template</span> &lt;<span class="c-k">typename</span>&gt; <span class="c-c">// This is the only change!
</span><span class="c-k">class</span> noncopyable {
<span class="c-k">public</span>:
    noncopyable(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
    noncopyable(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
    noncopyable&amp; <span class="c-k">operator</span>=(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
    noncopyable&amp; <span class="c-k">operator</span>=(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
<span class="c-k">protected</span>:
    noncopyable() = <span class="c-k">default</span>;
    ~noncopyable() = <span class="c-k">default</span>;
};
</code></pre><p>As long as the template parameters <var>T</var> and <var>U</var> are distinct types, <code>noncopyable&lt;T&gt;</code> and <code>noncopyable&lt;U&gt;</code> are distinct types, too.</p><p>Making <code>noncopyable</code> a template requires every type to somehow use a unique type as a parameter. Fortunately, there is an obvious solution: make every type use <em>itself</em> as the parameter:</p><pre class="codeblock" data-code-language="C++"><code><span class="c-k">class</span> foo : <span class="c-k">private</span> noncopyable&lt;foo&gt; {
    <span class="c-k">int</span> x;
};

<span class="c-k">class</span> bar : <span class="c-k">private</span> noncopyable&lt;bar&gt; {
    foo x;
};

<span class="c-c">// noncopyable&lt;foo&gt; and noncopyable&lt;bar&gt; are distinct types, so empty base
</span><span class="c-c">// optimization applies.
</span><span class="c-c">// True on every implementation that doesn't add gratuitous padding after
</span><span class="c-c">// the last member.
</span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(bar) == <span class="c-k">sizeof</span>(foo));
</code></pre><p>Granted, this doesn't protect against types that deliberately use another class as the dummy parameter. This is a non-issue in practice, however, as any such code can be immediately caught and rejected at review stage. The goal is to protect against Murphy, not Machiavelli.</p></section><section id="the-future-solution"><h2><a class="section-header-link" href="#the-future-solution">§</a>The (future) solution</h2><p>C++20 solves this problem by allowing an arbitrary non-static data member to disable the unique address requirement through the <code>[[no_unique_address]]</code> attribute, allowing <code>noncopyable</code> to be used as a regular member instead of a base class:</p><pre class="codeblock" data-code-language="C++"><code><span class="c-k">class</span> foo {
    [[no_unique_address]] noncopyable disable_copy_and_move;
    <span class="c-k">int</span> x;
};

<span class="c-c">// True on every implementation that doesn't add gratuitous padding after
</span><span class="c-c">// the last member.
</span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(foo) == <span class="c-k">sizeof</span>(<span class="c-k">int</span>));
</code></pre><p>An alternative, arguably semantically the cleanest, solution is to wait until <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p0707r4.pdf">the metaclass proposal</a> lands and implement <code>noncopyable</code> as a metaclass. There's no guarantee however when (and <em>if</em>) it will land, while C++20 is coming soon, and GCC 9 and Clang 9 already implement <code>[[no_unique_address]]</code>.</p></section></article></main><nav><ul id="prevnext"><li class="top"><a href="#">↑ Top ↑</a></li><li class="prev"><a rel="prev" href="/blue-ridge-status-update-dec-2019.html">← Older</a></li><li><a href="/archives/">Blog archives</a></li><li class="next"><a rel="next" href="/blue-ridge-errata-1.html">Newer →</a></li></ul></nav><footer><ul id="footerstuff"><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019-2020 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>