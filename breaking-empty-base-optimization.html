<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="generator" content="Some custom Common Lisp"><meta name="description" content="Empty base optimization in C++ is very brittle, how (not) to break it?"><script defer src="/static/fixes.js"></script><link rel="alternate" href="/feed.xml" title="Fanael's random ruminations" type="application/rss+xml"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>How to: accidentally break empty base optimization - Fanael's random ruminations</title></head><body><header id="top-header"><a id="skip-nav" class="at-only" href="#main">Skip to main content</a><div><span>Fanael's random ruminations</span></div></header><nav aria-label="Primary"><ul id="top-nav"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main id="main"><article><header><h1><a class="section-link" href="#main"><span>How to: accidentally break empty base optimization</span><span aria-hidden="true"> §</span></a></h1><p>Published on the <time datetime="2019-12-20">20th of December 2019</time></p><p>Topics: <a href="/archives/topic-i-hate-c++.html">i-hate-c++</a></p></header><p>A reasonably common idiom in C++ code is the use of the following or similar class to inhibit move and copy operations, to avoid having to repeat the four <code>delete</code>d functions in every class: </p><pre class="code-block"><span class="cx-language">C++</span>
<code class="cx-numbered"><span class="cx-l"><span><span class="c-k">class</span> <span class="c-nc">noncopyable</span> {
</span></span><span class="cx-l"><span><span class="c-k">public</span>:
</span></span><span class="cx-l"><span>    noncopyable(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
</span></span><span class="cx-l"><span>    noncopyable(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
</span></span><span class="cx-l"><span>    noncopyable&amp; <span class="c-k">operator</span>=(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
</span></span><span class="cx-l"><span>    noncopyable&amp; <span class="c-k">operator</span>=(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
</span></span><span class="cx-l"><span><span class="c-k">protected</span>:
</span></span><span class="cx-l"><span>    noncopyable() = <span class="c-k">default</span>;
</span></span><span class="cx-l"><span>    ~noncopyable() = <span class="c-k">default</span>;
</span></span><span class="cx-l"><span>};
</span></span></code></pre><div class="sidenote" role="note"><p>I'm personally not a huge fan of the <code>noncopyable</code> name, because it describes <em>how</em> instead of <em>why</em>, but that's neither here nor there.</p></div><p>The <code>noncopyable</code> class can be mixed in using inheritance, like so:</p><pre class="code-block"><span class="cx-language">C++</span>
<code class="cx-numbered"><span class="cx-l"><span><span class="c-k">class</span> <span class="c-nc">foo</span> : <span class="c-k">private</span> noncopyable {
</span></span><span class="cx-l"><span>    <span class="c-c">// …
</span></span></span><span class="cx-l"><span>};
</span></span></code></pre><p>So far, so good, but there's more to it than meets the eye.</p><nav class="toc" aria-labelledby="toc-label"><span id="toc-label">Table of contents</span><ol><li><a href="#the-problem">The problem</a></li><li><a href="#the-temporary-workaround">The (temporary) workaround</a></li><li><a href="#the-future-solution">The (future) solution</a></li></ol></nav><section id="the-problem"><h2><a class="section-link" href="#the-problem"><span>The problem</span><span aria-hidden="true"> §</span></a></h2><p>This definition of <code>noncopyable</code> relies heavily on <dfn>empty base optimization</dfn>: normally, every object in C++ has size of at least one byte and (equivalently) a unique address, but in certain conditions this requirement can be relaxed for <em>empty base subobjects</em>:</p><pre class="code-block"><span class="cx-language">C++</span>
<code class="cx-numbered"><span class="cx-l"><span><span class="c-k">class</span> <span class="c-nc">foo</span> : <span class="c-k">private</span> noncopyable {
</span></span><span class="cx-l"><span>    <span class="c-k">int</span> x;
</span></span><span class="cx-l"><span>};
</span></span><span class="cx-l"><span>
</span></span><span class="cx-l"><span class="c-c">// Always true.
</span></span><span class="cx-l"><span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(noncopyable) &gt;= <span class="c-m">1</span>);
</span></span><span class="cx-l"><span class="c-c">// True on every implementation that doesn't add gratuitous padding after
</span></span><span class="cx-l"><span class="c-c">// the last member.
</span></span><span class="cx-l"><span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(foo) == <span class="c-k">sizeof</span>(<span class="c-k">int</span>));
</span></span></code></pre><p>There is a problem, however. <strong>Empty base optimization can be applied only if the base class type is not the type, or a possibly-indirect base type of that type, of the first member</strong>, as the two subobjects are explicitly required to have distinct addresses. From this requirement it follows that the empty base optimization is <strong>prohibited</strong> in the following code:</p><pre class="code-block"><span class="cx-language">C++</span>
<code class="cx-numbered"><span class="cx-l"><span><span class="c-k">class</span> <span class="c-nc">foo</span> : <span class="c-k">private</span> noncopyable {
</span></span><span class="cx-l"><span>    <span class="c-k">int</span> x;
</span></span><span class="cx-l"><span>};
</span></span><span class="cx-l"><span>
</span></span><span class="cx-l"><span><span class="c-k">class</span> <span class="c-nc">bar</span> : <span class="c-k">private</span> noncopyable {
</span></span><span class="cx-l"><span>    foo x;
</span></span><span class="cx-l"><span>};
</span></span><span class="cx-l"><span>
</span></span><span class="cx-l"><span class="c-c">// Always true (!), as the noncopyable base subobject of foo and
</span></span><span class="cx-l"><span class="c-c">// the noncopyable base subobject of bar are required to have distinct
</span></span><span class="cx-l"><span class="c-c">// addresses.
</span></span><span class="cx-l"><span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(bar) &gt; <span class="c-k">sizeof</span>(foo));
</span></span></code></pre><p>Now, if non-copyability of <code>foo</code> is a part of its public API, one could argue that the solution is to just not declare <code>bar</code> as non-copyable; but if it's merely an implementation detail, not explicitly making <code>bar</code> non-copyable couples it too tightly to the implementation of <code>foo</code> and as such should be, in my opinion at least, avoided.</p></section><section id="the-temporary-workaround"><h2><a class="section-link" href="#the-temporary-workaround"><span>The (temporary) workaround</span><span aria-hidden="true"> §</span></a></h2><p>There are ways to work around this problem. One such way is to use a preprocessor macro instead of mixing in a base class, but the C++ preprocessor is absolutely awful, so I'd rather not go this route.</p><p>The solution I personally prefer exploits the fact that one of the requirements for the empty base optimization to apply is that the base class is not of <em>the same type</em> as the first non-static data member or one of its bases. What if there was a way to create similar types that are completely distinct? There is, that's precisely what C++ templates are for:</p><pre class="code-block"><span class="cx-language">C++</span>
<code class="cx-numbered"><span class="cx-l"><span><span class="c-k">template</span> &lt;<span class="c-k">typename</span>&gt; <span class="c-c">// This is the only change!
</span></span></span><span class="cx-l"><span><span class="c-k">class</span> <span class="c-nc">noncopyable</span> {
</span></span><span class="cx-l"><span><span class="c-k">public</span>:
</span></span><span class="cx-l"><span>    noncopyable(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
</span></span><span class="cx-l"><span>    noncopyable(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
</span></span><span class="cx-l"><span>    noncopyable&amp; <span class="c-k">operator</span>=(<span class="c-k">const</span> noncopyable&amp;) = <span class="c-k">delete</span>;
</span></span><span class="cx-l"><span>    noncopyable&amp; <span class="c-k">operator</span>=(noncopyable&amp;&amp;) = <span class="c-k">delete</span>;
</span></span><span class="cx-l"><span><span class="c-k">protected</span>:
</span></span><span class="cx-l"><span>    noncopyable() = <span class="c-k">default</span>;
</span></span><span class="cx-l"><span>    ~noncopyable() = <span class="c-k">default</span>;
</span></span><span class="cx-l"><span>};
</span></span></code></pre><p>As long as the template parameters <var>T</var> and <var>U</var> are distinct types, <code>noncopyable&lt;T&gt;</code> and <code>noncopyable&lt;U&gt;</code> are distinct types, too.</p><p>Making <code>noncopyable</code> a template requires every type to somehow use a unique type as a parameter. Fortunately, there is an obvious solution: make every type use <em>itself</em> as the parameter:</p><pre class="code-block"><span class="cx-language">C++</span>
<code class="cx-numbered"><span class="cx-l"><span><span class="c-k">class</span> <span class="c-nc">foo</span> : <span class="c-k">private</span> noncopyable&lt;foo&gt; {
</span></span><span class="cx-l"><span>    <span class="c-k">int</span> x;
</span></span><span class="cx-l"><span>};
</span></span><span class="cx-l"><span>
</span></span><span class="cx-l"><span><span class="c-k">class</span> <span class="c-nc">bar</span> : <span class="c-k">private</span> noncopyable&lt;bar&gt; {
</span></span><span class="cx-l"><span>    foo x;
</span></span><span class="cx-l"><span>};
</span></span><span class="cx-l"><span>
</span></span><span class="cx-l"><span class="c-c">// noncopyable&lt;foo&gt; and noncopyable&lt;bar&gt; are distinct types, so empty base
</span></span><span class="cx-l"><span class="c-c">// optimization applies.
</span></span><span class="cx-l"><span class="c-c">// True on every implementation that doesn't add gratuitous padding after
</span></span><span class="cx-l"><span class="c-c">// the last member.
</span></span><span class="cx-l"><span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(bar) == <span class="c-k">sizeof</span>(foo));
</span></span></code></pre><p>Granted, this doesn't protect against types that deliberately use another class as the dummy parameter. This is a non-issue in practice, however, as any such code can be immediately caught and rejected at review stage. The goal is to protect against Murphy, not Machiavelli.</p></section><section id="the-future-solution"><h2><a class="section-link" href="#the-future-solution"><span>The (future) solution</span><span aria-hidden="true"> §</span></a></h2><p>C++20 solves this problem by allowing an arbitrary non-static data member to disable the unique address requirement through the <code>[[no_unique_address]]</code> attribute, allowing <code>noncopyable</code> to be used as a regular member instead of a base class:</p><pre class="code-block"><span class="cx-language">C++</span>
<code class="cx-numbered"><span class="cx-l"><span><span class="c-k">class</span> <span class="c-nc">foo</span> {
</span></span><span class="cx-l"><span>    [[no_unique_address]] noncopyable disable_copy_and_move;
</span></span><span class="cx-l"><span>    <span class="c-k">int</span> x;
</span></span><span class="cx-l"><span>};
</span></span><span class="cx-l"><span>
</span></span><span class="cx-l"><span class="c-c">// True on every implementation that doesn't add gratuitous padding after
</span></span><span class="cx-l"><span class="c-c">// the last member.
</span></span><span class="cx-l"><span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(foo) == <span class="c-k">sizeof</span>(<span class="c-k">int</span>));
</span></span></code></pre><p>An alternative, arguably semantically the cleanest, solution is to wait until <a href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2019/p0707r4.pdf">the metaclass proposal (PDF, 1.5 MB)</a> lands and implement <code>noncopyable</code> as a metaclass. There's no guarantee however when (and <em>if</em>) it will land, while C++20 is coming soon, and GCC 9 and Clang 9 already implement <code>[[no_unique_address]]</code>.</p></section></article></main><nav aria-label="Chronological, secondary"><ul id="order-nav"><li class="top"><a href="#skip-nav"><span aria-hidden="true">↑ </span>Top<span aria-hidden="true"> ↑</span></a></li><li class="prev"><a rel="prev" href="/blue-ridge-status-update-dec-2019.html"><span aria-hidden="true">← </span>Older</a></li><li><a href="/archives/">Blog archives</a></li><li class="next"><a rel="next" href="/blue-ridge-errata-1.html">Newer<span aria-hidden="true"> →</span></a></li></ul></nav><footer><ul id="footer"><li><a href="/pages/offline-mode.html">Offline mode</a></li><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019-2023 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>