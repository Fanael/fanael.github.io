<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="generator" content="Some custom Common Lisp"><meta name="description" content="Blog archives for topic mythbusting"><script defer src="/static/fixes.js"></script><link rel="alternate" href="/feed.xml" title="Fanael's random ruminations" type="application/rss+xml"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>Blog archives for topic mythbusting - Fanael's random ruminations</title></head><body><header id="top-header"><a id="skip-nav" class="at-only" href="#main">Skip to main content</a><div><span>Fanael's random ruminations</span></div></header><nav aria-label="Primary"><ul id="top-nav"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main id="main"><header><h1>Archives for topic mythbusting</h1></header><nav class="toc" aria-labelledby="toc-label"><span id="toc-label">Table of contents</span><ol><li><a href="#dependency-breaking-xor-p6">Dependency-breaking zeroing XOR in P6</a></li><li><a href="#is-x86-risc-internally">The legend of "x86 CPUs decode instructions into RISC form internally"</a></li></ol></nav><article id="dependency-breaking-xor-p6"><header><h2><a href="/dependency-breaking-xor-p6.html">Dependency-breaking zeroing XOR in P6</a></h2><p>Published on the <time datetime="2021-04-08">8th of April 2021</time></p><p>Topics: <a href="/archives/topic-microarchitecture-archeology.html">microarchitecture-archeology</a>, <a href="/archives/topic-mythbusting.html">mythbusting</a></p></header><p>In x86 assembly language, a common idiom for setting the value of a register to 0 is to use the exclusive-or instruction with both operands being the same register, such as <code>xor eax, eax</code>. It was originally intended as a size optimization: the obvious <code>mov eax, 0</code> is encoded as <em>five</em> bytes, of which four are used to store the constant 0, while the exclusive-or solution needs merely <em>two</em>, and is equally as fast, so it quickly became widespread.</p><p>By the time the P6 microarchitecture was being designed, the <code>xor</code> zeroing idiom was already nigh-universal in compiler output and hand-written assembly alike, so it was specifically recognized as a zeroing idiom for the purpose of avoiding partial register stalls in code such as this:</p><pre class="code-block"><span class="cx-language">x86 assembly</span>
<code class="cx-numbered"><span class="cx-l"><span>    <span class="c-nf">xor</span> <span class="c-nb">eax</span>, <span class="c-nb">eax</span>
</span></span><span class="cx-l"><span>    <span class="c-nf">mov</span> <span class="c-nb">al</span>, [<span class="c-nb">ecx</span>]
</span></span><span class="cx-l"><span>    <span class="c-c">; use eax</span>
</span></span></code></pre><p>In code tuned for the original Pentium or earlier processors, this was the usual way of zero-extending an 8-bit (or 16-bit with <code>ax</code> instead of <code>al</code>) value into the full 32-bit register, as the <code>movzx</code> instruction was slower. P6, starting from the very first Pentium Pro, recognized that after a <code>xor</code> of a register with itself, the register held 0, which avoided the partial register stall that would otherwise occur when modifying a low part of a register followed by operations on the full 32 bits.</p><p>Unfortunately, the Pentium Pro as originally designed was too ambitious to be realized using then-available lithography technology without making the chip too big — and thus too prone to manufacturing defects — so some features had to go. Segment register renaming and beefier secondary decoders were some of the notable victims of that process.</p><p>I assume that the ability to recognize that the exclusive-or zeroing idiom doesn't <em>really</em> depend on the previous value of a register, so that it can be dispatched immediately without waiting for the old value — thus breaking the dependency chain — met the same fate; the Pentium Pro shipped without it.</p><p>Some of the cut features were introduced in later models: segment register renaming, for example, was added back in the Pentium II. Maybe dependency-breaking zeroing XOR was added in later P6 models too? After all, it seems such a simple yet important thing, and indeed, I remember seeing people claim that's the case in some old forum posts and mailing list messages. On the other hand, some sources, such as <a href="https://www.agner.org/optimize/">Agner Fog's optimization manuals</a> say that not only it was never present in any of the P6 processors, it was also missing in Pentium M.</p><p>Whatever the case may be, there's only one way to make sure: test it!</p><a class="read-full" href="/dependency-breaking-xor-p6.html" aria-label="Read the full article: Dependency-breaking zeroing XOR in P6">Read the full article…</a></article><article id="is-x86-risc-internally"><header><h2><a href="/is-x86-risc-internally.html">The legend of "x86 CPUs decode instructions into RISC form internally"</a></h2><p>Published on the <time datetime="2020-06-30">30th of June 2020</time></p><p>Topics: <a href="/archives/topic-microarchitectural-musings.html">microarchitectural-musings</a>, <a href="/archives/topic-mythbusting.html">mythbusting</a></p></header><p>There is a widespread idea that modern high-performance x86 processors work by decoding the "complex" x86 instructions into "simple" RISC-like instructions that the rest of the pipeline then operates on. But how close is this idea to how the processors <em>actually</em> work internally?</p><p>To answer this question, let's analyze how different x86 processors, ranging from the first "modern" Intel microarchitecture, P6, to their current designs, handle the following simple loop (the code is 32-bit just to allow us to discuss very old x86 processors):</p><pre class="code-block"><span class="cx-language">x86 assembly</span>
<code class="cx-numbered"><span class="cx-l"><span>.loop:
</span></span><span class="cx-l"><span>    <span class="c-nf">add</span> [<span class="c-nb">edx</span>], <span class="c-nb">eax</span>
</span></span><span class="cx-l"><span>    <span class="c-nf">add</span> <span class="c-nb">edx</span>, <span class="c-m">4</span>
</span></span><span class="cx-l"><span>    <span class="c-nf">sub</span> <span class="c-nb">eax</span>, <span class="c-m">1</span>
</span></span><span class="cx-l"><span>    <span class="c-nf">jnz</span> .loop
</span></span></code></pre><a class="read-full" href="/is-x86-risc-internally.html" aria-label="Read the full article: The legend of &quot;x86 CPUs decode instructions into RISC form internally&quot;">Read the full article…</a></article></main><nav aria-label="Chronological, secondary"><ul id="order-nav"><li class="top"><a href="#skip-nav"><span aria-hidden="true">↑ </span>Top<span aria-hidden="true"> ↑</span></a></li><li class="prev"></li><li><a href="/archives/">Blog archives</a></li><li class="next"></li></ul></nav><footer><ul id="footer"><li><a href="/pages/offline-mode.html">Offline mode</a></li><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019-2023 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>