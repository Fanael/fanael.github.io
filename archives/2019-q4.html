<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Security-Policy" content="default-src 'self'"><meta name="generator" content="Some custom Common Lisp"><link rel="canonical" href="archives/2019-q4.html"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>Blog archives for the fourth quarter of 2019 - Fanael's random ruminations</title></head><body><header id="mainheader">Fanael's random ruminations</header><nav><ul id="navmenu"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main><header><h1>Archives for the fourth quarter of 2019</h1></header><nav class="toc"><ol><li><a href="#hardware-prefetching-in-pentium-iii">Hardware prefetching in Pentium III</a></li><li><a href="#incremental-low-pause-gc">A simple incremental low-pause GC design</a></li></ol></nav><article id="hardware-prefetching-in-pentium-iii"><header><h2><a href="/hardware-prefetching-in-pentium-iii.html">Hardware prefetching in Pentium III</a></h2><p class="publishdate">Published on the <time datetime="2019-10-25">25th of October 2019</time></p></header><p>Nowadays pretty much every processor featuring cache hierarchy has some form of automatic memory prefetch mechanism. In small low-power processors it may be very simplistic and only prefetch if the addresses are increasing, in high-performance processors it may try to predict all sorts of regular and semi-regular patterns, but the basic mechanism <em>will be</em> present in some form.</p><p>We weren't, however, always so lucky. The first mainstream x86 processor with hardware prefetching logic was the Pentium 4 Willamette, first released in November 2000, which used the highly contentious NetBurst microarchitecture. Due to Willamette's mediocrity, Intel didn't kill off their older P6 microarchitecture, and so the hardware prefetching was later supposedly added to the P6-based Pentium III Tualatin (released in June 2001), where its efficacy was disputed due to much lower CPU-chipset bandwidth compared to NetBurst.</p><aside><p>The P6 microarchitecture introduced in Pentium Pro, in 1995, and used with minor changes in Pentium II and III, is a direct ancestor of Intel's current high-performance x86 microarchitectures — at the time of writing, Ice Like for mobile, Skylake for everything else. There were many improvements in the last 24 years, and most major bottlenecks were fixed, but the family resemblance is still there.</p><p>P6's direct successor was Pentium M, created for mobile processors due to NetBurst's high power draw rendering it unsuitable for those applications. The Core microarchitecture powering the famous Core 2 series, that let Intel take the performance crown back from AMD after years of humiliation due to their marketing-driven, physics-ignoring bet on NetBurst, was a direct successor of Pentium M.</p></aside><p>But how effective was the hardware prefetching in Tualatin, really? And is it really true that Coppermine, the Pentium III revision preceding Tualatin, didn't feature automatic prefetching? Fortunately, by choosing an appropriate test case and using CPU performance counters, it is possible to perform a gray-box test that answers these questions.</p></article><article id="incremental-low-pause-gc"><header><h2><a href="/incremental-low-pause-gc.html">A simple incremental low-pause GC design</a></h2><p class="publishdate">Published on the <time datetime="2019-10-12">12th of October 2019</time></p></header><p>There are too many garbage-collected runtimes using very simplistic designs, such as reference counting or naïve stop the world mark and sweep. These are valid choices in that they're simple and correct, but unfortunately they induce undue costs, such as unpredictable and unbounded pause times.</p><p>I decided to have a go at designing and implementing something better as a part of my custom lisp-dialect implementation, and this blog post is an attempt to describe and organize this design. <strong>Since my toy lisp is single-threaded, so is its garbage collector</strong>. It is possible to extend this design into a parallel one, it just is not one of my goals.</p><p>It should be noted that this design is in no way revolutionary, I'm merely following existing techniques. In particular, <a href="https://wiki.openjdk.java.net/display/shenandoah/Main">Red Hat's excellent Shenandoah</a> has been a major inspiration.</p></article></main><nav><ul id="prevnext"><li class="top"><a href="#">↑ Top ↑</a></li><li class="prev"></li><li><a href="/archives/">Blog archives</a></li><li class="next"></li></ul></nav><footer><ul id="footerstuff"><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>