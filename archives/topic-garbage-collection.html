<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Security-Policy" content="default-src 'self'; object-src 'none'"><meta name="generator" content="Some custom Common Lisp"><link rel="alternate" href="/feed.xml" title="Fanael's random ruminations" type="application/rss+xml"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>Blog archives for topic garbage-collection - Fanael's random ruminations</title></head><body><a id="skip-nav" href="#main">Skip to main content</a><header id="mainheader">Fanael's random ruminations</header><nav aria-label="Primary"><ul id="navmenu"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main id="main"><header><h1>Archives for topic garbage-collection</h1></header><nav class="toc" aria-labelledby="toc-label"><span id="toc-label">Table of contents</span><ol><li><a href="#blue-ridge-errata-1">Blue Ridge errata #1: root pointers during evacuation</a></li><li><a href="#blue-ridge-status-update-dec-2019">Blue Ridge status update: December 2019</a></li><li><a href="#incremental-low-pause-gc">A simple incremental low-pause GC design</a></li></ol></nav><article id="blue-ridge-errata-1"><header><h2><a href="/blue-ridge-errata-1.html">Blue Ridge errata #1: root pointers during evacuation</a></h2><p>Published on the <time datetime="2020-02-08">8th of February 2020</time></p><p>Topics: <a href="/archives/topic-garbage-collection.html">garbage-collection</a></p></header><p>While trying to implement concurrent evacuation I've found out that there is a serious problem with <a href="/incremental-low-pause-gc.html">my simple incremental low-pause garbage collector</a> design. Implementing the <a href="/incremental-low-pause-gc.html#phases">phase ordering</a> exactly as specified <strong>would corrupt the root set</strong>, resulting in not very fun to debug crashes, even with extensive heap verification and lots of assertions everywhere. Why? Let's go through the pertinent assumptions, and the way they interact, carefully, and find a solution.</p><a class="read-full" href="/blue-ridge-errata-1.html" aria-label="Read the full article: Blue Ridge errata #1: root pointers during evacuation">Read the full article…</a></article><article id="blue-ridge-status-update-dec-2019"><header><h2><a href="/blue-ridge-status-update-dec-2019.html">Blue Ridge status update: December 2019</a></h2><p>Published on the <time datetime="2019-12-08">8th of December 2019</time></p><p>Topics: <a href="/archives/topic-garbage-collection.html">garbage-collection</a></p></header><p>Just a "quick" update on the development status of <a href="/incremental-low-pause-gc.html">my low-pause incremental garbage collector</a> (code name <dfn>Blue Ridge</dfn>): it's progressing rather nicely, considering how little motivation my clinically depressed self is able to muster up most days.</p><aside><p>No points for guessing where the code name comes from.</p></aside><p>The garbage collector as currently implemented, in just above 2 thousand lines of code, is already <em>working</em>, that is, it correctly allocates memory and collects garbage, <em>even under address and undefined behavior sanitizers</em>, though it's limited to stop-the-world operation at the moment. This is merely a pragmatic decision on what order to do things in: I'd rather have heap verifiers implemented and tested before diving into incrementality, as catching any potential heap corruptions or invariant violations right away is much preferable to trying to divine the cause of a crash from a core dump.</p><p>That being said, most of the hard work for supporting incremental collections has already been done. Most of the collector's code is written in a way that makes incremental work easy enough, it just happens to not be used in that way yet.</p><p>Performance appears to be fine so far. Pure allocation rate of object that die quickly is limited by how fast the CPU is able to write object data to memory, like in any good moving GC, as the hot path of allocation consists of just advancing a pointer. Collection time is dominated by marking, as one could expect. Throughput, measured by taking the wall-clock time of a program that allocates a linked list of 10 million conses then throws it away, repeating 500 times, is not bad either, being within the same order of magnitude as <a href="https://wiki.openjdk.java.net/display/shenandoah/Main">HotSpot's Shenandoah collector</a> in its passive (stop-the-world only) mode, and <em>beating handily</em> its Parallel and G1 collectors with all four collectors limited to a 1 GB heap, which again, is not unexpected: this is not a very good workload+heap size combination for generational collectors, as they're forced to prematurely tenure conses, which then results in a significant number of painful major collections, while Blue Ridge and Shenandoah aren't affected due to their non-generational nature.</p><p>Blue Ridge in its current state also features <dfn>policies</dfn>, switchable at runtime, that are informed whenever interesting events happen, such as a new region being allocated or the current phase being changed, and that in turn decide whether or not start a cycle, and if so what kind — incremental or stop-the-world — and what regions should belong to the collection set. It is through this mechanism that the aforementioned 1 GB heap limit has been implemented, as Blue Ridge's heap is normally discontinuous, dynamically resizable in either direction and theoretically unlimited.</p><p>All things considered, the development of my garbage collector is progressing well, if slowly due to circumstances beyond my control. I hope I'll be able to have a functionally complete version soon, because that's where the real fun begins: playing around with all the knobs the get the lowest latency, lowest footprint and highest throughput possible.</p><a class="read-full" href="/blue-ridge-status-update-dec-2019.html" aria-label="Read the full article: Blue Ridge status update: December 2019">Read the full article…</a></article><article id="incremental-low-pause-gc"><header><h2><a href="/incremental-low-pause-gc.html">A simple incremental low-pause GC design</a></h2><p>Published on the <time datetime="2019-10-12">12th of October 2019</time></p><p>Topics: <a href="/archives/topic-garbage-collection.html">garbage-collection</a></p></header><p>There are too many garbage-collected runtimes using very simplistic designs, such as reference counting or naïve stop the world mark and sweep. These are valid choices in that they're simple and correct, but unfortunately they induce undue costs, such as unpredictable and unbounded pause times.</p><p>I decided to have a go at designing and implementing something better as a part of my custom lisp-dialect implementation, and this blog post is an attempt to describe and organize this design. <strong>Since my toy lisp is single-threaded, so is its garbage collector</strong>. It is possible to extend this design into a parallel one, it just is not one of my goals.</p><p>It should be noted that this design is in no way revolutionary, I'm merely following existing techniques. In particular, <a href="https://wiki.openjdk.java.net/display/shenandoah/Main">Red Hat's excellent Shenandoah</a> has been a major inspiration.</p><a class="read-full" href="/incremental-low-pause-gc.html" aria-label="Read the full article: A simple incremental low-pause GC design">Read the full article…</a></article></main><nav aria-label="Chronological, secondary"><ul id="prevnext"><li class="top"><a href="#skip-nav">↑ Top ↑</a></li><li class="prev"></li><li><a href="/archives/">Blog archives</a></li><li class="next"></li></ul></nav><footer><ul id="footerstuff"><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019-2021 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>