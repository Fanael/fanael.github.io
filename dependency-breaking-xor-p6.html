<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="generator" content="Some custom Common Lisp"><meta name="description" content="An attempt to discover if the zeroing XOR idiom is dependency-breaking in any P6 and Pentium M models"><script defer src="/static/fixes.js"></script><link rel="alternate" href="/feed.xml" title="Fanael's random ruminations" type="application/rss+xml"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>Dependency-breaking zeroing XOR in P6 - Fanael's random ruminations</title></head><body><header id="top-header"><a id="skip-nav" class="at-only" href="#main">Skip to main content</a><span>Fanael's random ruminations</span></header><nav aria-label="Primary"><ul id="top-nav"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main id="main"><article><header><h1><a class="section-link" href="#main"><span>Dependency-breaking zeroing XOR in P6</span><span aria-hidden="true"> §</span></a></h1><p>Published on the <time datetime="2021-04-08">8th of April 2021</time></p><p>Topics: <a href="/archives/topic-microarchitecture-archeology.html">microarchitecture-archeology</a>, <a href="/archives/topic-mythbusting.html">mythbusting</a></p></header><p>In x86 assembly language, a common idiom for setting the value of a register to 0 is to use the exclusive-or instruction with both operands being the same register, such as <code>xor eax, eax</code>. It was originally intended as a size optimization: the obvious <code>mov eax, 0</code> is encoded as <em>five</em> bytes, of which four are used to store the constant 0, while the exclusive-or solution needs merely <em>two</em>, and is equally as fast, so it quickly became widespread.</p><p>By the time the P6 microarchitecture was being designed, the <code>xor</code> zeroing idiom was already nigh-universal in compiler output and hand-written assembly alike, so it was specifically recognized as a zeroing idiom for the purpose of avoiding partial register stalls in code such as this:</p><pre class="code-block"><span class="cx-language">x86 assembly</span>
<code class="cx-numbered"><span class="cx-l"><span>    <span class="c-nf">xor</span> <span class="c-nb">eax</span>, <span class="c-nb">eax</span>
</span></span><span class="cx-l"><span>    <span class="c-nf">mov</span> <span class="c-nb">al</span>, [<span class="c-nb">ecx</span>]
</span></span><span class="cx-l"><span>    <span class="c-c">; use eax</span>
</span></span></code></pre><p>In code tuned for the original Pentium or earlier processors, this was the usual way of zero-extending an 8-bit (or 16-bit with <code>ax</code> instead of <code>al</code>) value into the full 32-bit register, as the <code>movzx</code> instruction was slower. P6, starting from the very first Pentium Pro, recognized that after a <code>xor</code> of a register with itself, the register held 0, which avoided the partial register stall that would otherwise occur when modifying a low part of a register followed by operations on the full 32 bits.</p><p>Unfortunately, the Pentium Pro as originally designed was too ambitious to be realized using then-available lithography technology without making the chip too big — and thus too prone to manufacturing defects — so some features had to go. Segment register renaming and beefier secondary decoders were some of the notable victims of that process.</p><p>I assume that the ability to recognize that the exclusive-or zeroing idiom doesn't <em>really</em> depend on the previous value of a register, so that it can be dispatched immediately without waiting for the old value — thus breaking the dependency chain — met the same fate; the Pentium Pro shipped without it.</p><p>Some of the cut features were introduced in later models: segment register renaming, for example, was added back in the Pentium II. Maybe dependency-breaking zeroing XOR was added in later P6 models too? After all, it seems such a simple yet important thing, and indeed, I remember seeing people claim that's the case in some old forum posts and mailing list messages. On the other hand, some sources, such as <a href="https://www.agner.org/optimize/">Agner Fog's optimization manuals</a> say that not only it was never present in any of the P6 processors, it was also missing in Pentium M.</p><p>Whatever the case may be, there's only one way to make sure: test it!</p><nav class="toc" aria-labelledby="toc-label"><span id="toc-label">Table of contents</span><ol><li><a href="#test">The test</a></li><li><a href="#results">The results</a><ol><li><a href="#tualatin">P6: Tualatin</a></li><li><a href="#dothan">Pentium M: Dothan</a></li><li><a href="#yonah">Enhanced Pentium M: Yonah</a></li><li><a href="#core">Core, just for comparison</a></li></ol></li><li><a href="#conclusion">The conclusion</a></li></ol></nav><section id="test"><h2><a class="section-link" href="#test"><span>The test</span><span aria-hidden="true"> §</span></a></h2><p>To test for dependency-breaking behavior, we simply need to create a long dependency chain, interspersed by the tested instructions. I somewhat arbitrarily chose multiplication as the instruction to form the chain with, because its significant latency, yet single-cycle reciprocal throughput makes it trivial to see if we're bound by throughput (in which case the dependency chain is broken) or by latency (in which case it's not). Therefore, the tested loop will look like this, using the <a href="https://www.nasm.us/">Netwide Assembler</a> syntax:</p><pre class="code-block"><span class="cx-language">x86 assembly</span>
<code class="cx-numbered"><span class="cx-l"><span>.loop:
</span></span><span class="cx-l"><span class="c-c">    %rep 10
</span></span><span class="cx-l"><span>    <span class="c-nf">xor</span> <span class="c-nb">eax</span>, <span class="c-nb">eax</span>
</span></span><span class="cx-l"><span>    <span class="c-nf">imul</span> <span class="c-nb">eax</span>, <span class="c-nb">eax</span>
</span></span><span class="cx-l"><span class="c-c">    %endrep
</span></span><span class="cx-l"><span>    <span class="c-nf">dec</span> <span class="c-nb">ecx</span>
</span></span><span class="cx-l"><span>    <span class="c-nf">jnz</span> .loop
</span></span></code></pre><p>MMX and SSE instruction sets were tested the same way, using <code>pxor</code> and <code>xorps</code> respectively instead of <code>xor</code>, and <code>pmullw</code> and <code>mulss</code> respectively as the multiplication.</p><p>The initial value of <code>ecx</code> doesn't matter much, it only needs to be big enough to make process initialization costs and noise insignificant. I chose one million.</p></section><section id="results"><h2><a class="section-link" href="#results"><span>The results</span><span aria-hidden="true"> §</span></a></h2><section id="tualatin"><h3><a class="section-link" href="#tualatin"><span>P6: Tualatin</span><span aria-hidden="true"> §</span></a></h3><p>The first machine I tested was my trusty old ThinkPad, with a Tualatin Pentium III. It was the third and final release of Pentium III and P6 proper, so surely if P6 recognized zeroing XOR as dependency-breaking at any point, it would do it here. After all, it was released <em>after</em> the first NetBurst processors, where same-register exclusive-or <em>was</em> breaking dependency chains. When we run the test code under <cite class="program-name">perf</cite>, we get the following cycle counts:</p><ul><li><b><code>mov eax, ecx</code></b> (control): 14.5 million cycles</li><li><b><code>xor eax, eax</code></b>: 50.3 million cycles</li><li><b><code>pxor mm0, mm0</code></b>: 40.5 million cycles</li><li><b><code>xorps xmm0, xmm0</code></b>: 51.2 million cycles</li></ul><p>Zeroing exclusive-or clearly does <em>not</em> break dependency chains at all. If it did, the cycle counters would be more similar to the control. We're limited by the latency of multiplication: 3 cycles for 16-bit SIMD integer, 4 cycles for 32-bit scalar integer and floating point, plus one cycle for the exclusive-or itself.</p></section><section id="dothan"><h3><a class="section-link" href="#dothan"><span>Pentium M: Dothan</span><span aria-hidden="true"> §</span></a></h3><p>Since it appears that dependency-breaking zeroing XOR is not present in the last revision of P6 proper, time to go for a newer target: Pentium M. I tested Dothan, the second revision of Pentium M, built using 90 nm process. The results appear as follows:</p><ul><li><b><code>mov eax, ecx</code></b> (control): 12.0 million cycles</li><li><b><code>xor eax, eax</code></b>: 50.2 million cycles</li><li><b><code>pxor mm0, mm0</code></b>: 40.3 million cycles</li><li><b><code>xorps xmm0, xmm0</code></b>: 51.2 million cycles</li></ul><p>Exact same story here: none of the zeroing exclusive-or operations break dependency chains.</p></section><section id="yonah"><h3><a class="section-link" href="#yonah"><span>Enhanced Pentium M: Yonah</span><span aria-hidden="true"> §</span></a></h3><p>If not Pentium M, then maybe the short-lived Enhanced Pentium M? It did feature some notable improvements to the microarchitecture, after all, so let's try it too:</p><ul><li><b><code>mov eax, ecx</code></b> (control): 12.0 million cycles</li><li><b><code>xor eax, eax</code></b>: 12.7 million cycles</li><li><b><code>pxor mm0, mm0</code></b>: 40.3 million cycles</li><li><b><code>xorps xmm0, xmm0</code></b>: 18.6 million cycles</li></ul><p>Oh. Huh. It appears that zeroing XOR <em>is</em> recognized as dependency-breaking, at least with regards to general purpose and SSE registers. The zeroing operation still appears to consume an execution unit, which explains why the SSE version is slower: since the vector execution units are 64-bit, the <code>xorps</code> instruction is split into two micro-operations, each going to a different execution unit, of which there are just <em>two</em>.</p><p>Zeroing exclusive-or on MMX registers is presumably not recognized due to the fact that MMX registers alias the x87 register stack, complicating the implementation a bit.</p></section><section id="core"><h3><a class="section-link" href="#core"><span>Core, just for comparison</span><span aria-hidden="true"> §</span></a></h3><p>In Core, a microarchitecture where almost every aspect was greatly improved compared to Pentium M and P6, zeroing XOR idioms are recognized directly by the register renaming mechanism and do not consume execution units. As such, its results appear quite… uniform:</p><ul><li><b><code>mov eax, ecx</code></b> (control): 10.3 million cycles</li><li><b><code>xor eax, eax</code></b>: 10.3 million cycles</li><li><b><code>pxor mm0, mm0</code></b>: 10.3 million cycles</li><li><b><code>xorps xmm0, xmm0</code></b>: 10.3 million cycles</li></ul></section></section><section id="conclusion"><h2><a class="section-link" href="#conclusion"><span>The conclusion</span><span aria-hidden="true"> §</span></a></h2><p>Agner Fog is correct here, as I expected: neither P6 nor the first two revisions of Pentium M recognize same-register exclusive-or as dependency breaking, even though they do recognize it as preventing certain kinds of partial register stalls. The first P6 descendant to feature this behavior is the <em>third</em> revision of Pentium M, the so-called Enhanced Pentium M, where same-register exclusive-or breaks the dependency chain on the given register for general purpose and SSE registers, but not MMX registers.</p></section></article></main><nav aria-label="Chronological, secondary"><ul id="order-nav"><li class="top"><a href="#skip-nav"><span aria-hidden="true">↑ </span>Top<span aria-hidden="true"> ↑</span></a></li><li class="prev"><a rel="prev" href="/blog-update.html"><span aria-hidden="true">← </span>Older</a></li><li><a href="/archives/">Blog archives</a></li><li class="next"><a rel="next" href="/dotnet-object-init-slow.html">Newer<span aria-hidden="true"> →</span></a></li></ul></nav><footer><ul id="footer"><li><a href="/pages/offline-mode.html">Offline mode</a></li><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019-2023 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>