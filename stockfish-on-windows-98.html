<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="generator" content="Some custom Common Lisp"><meta name="description" content="Porting current versions of Stockfish to Windows 98: is it possible, and how much tinkering does it require?"><link rel="alternate" href="/feed.xml" title="Fanael's random ruminations" type="application/rss+xml"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>Current Stockfish on Windows 98?! - Fanael's random ruminations</title></head><body><a id="skip-nav" class="at-only" href="#main">Skip to main content</a><header id="top-header">Fanael's random ruminations</header><nav aria-label="Primary"><ul id="top-nav"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main id="main"><article><header><h1><a class="section-link" href="#main"><span>Current Stockfish on Windows 98?!</span><span aria-hidden="true"> §</span></a></h1><p>Published on the <time datetime="2020-09-24">24th of September 2020</time></p><p>Topics: <a href="/archives/topic-retro.html">retro</a>, <a href="/archives/topic-windows-9x.html">windows-9x</a></p></header><p>A few weeks ago I had this weird idea: would it be possible to make an up-to-date version of <a href="https://stockfishchess.org/">Stockfish</a> run on Windows 98? There's an immediate problem with that: Stockfish is written in C++17, which is the still-current, at the time of writing, revision of the C++ language; surely there are no C++17 capable compilers that can still target something as old as Windows 98?</p><div class="info"><p>Disclaimer: in this article, by "Windows 98" I mean Windows 98 second edition with the main files of the <a href="https://www.techtalk.cc/viewtopic.php?t=65">unofficial service pack</a> installed, which is a convenient bundle of official and unofficial patches. I don't care about Windows 98 first edition, nor the second edition <em>without</em> those updates installed. Note that <a href="https://sourceforge.net/projects/kernelex/">KernelEx</a> is <em>not needed</em>.</p><p>I'm fully aware this has no practical value, but it was a fun thing to do.</p></div><p>As it turns out, the GNU toolchain, comprised of <a href="https://www.gnu.org/software/binutils/">GNU binutils</a> and <a href="https://gcc.gnu.org/">GCC, the GNU Compiler Collection</a>, doesn't particularly care about all the different Windows versions and will happily output a binary that works on any 32-bit Windows.</p><p>The compiler itself, assembler and linker are only a part of a functional compiler package, though. There's one part we're missing: the runtime library, which provides the system-specific program initialization code that runs before the <code>main</code> function. Since we're using GCC, the obvious choice is the <a href="https://sourceforge.net/projects/mingw-w64/">mingw-w64</a> runtime. It also provides Windows API headers, bindings to (pretty much all the extant versions of) the Microsoft Visual C++ standard C library, and a POSIX threading API compatibility layer, <cite class="program-name">winpthreads</cite>, which is required for C++ standard threading library support in GCC.</p><p>Fortunately for us, a minimal Windows program compiled with GCC with mingw-w64 appears to work fine when executed under Windows 98:</p><pre class="code-block"><span class="language">C++</span>
<code class="numbered"><span class="ln at-only-b"></span><span><span class="c-c">#include</span> <span class="c-c">&lt;windows.h&gt;
</span></span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span><span class="c-k">int</span> WINAPI WinMain(HINSTANCE, HINSTANCE, <span class="c-k">char</span>*, <span class="c-k">int</span>)
</span><span class="ln at-only-b"></span><span>{
</span><span class="ln at-only-b"></span><span>    MessageBoxA(<span class="c-k">nullptr</span>, <span class="c-s">"Hello world!"</span>, <span class="c-s">"A test"</span>, MB_OK);
</span><span class="ln at-only-b"></span><span>    <span class="c-k">return</span> <span class="c-m">0</span>;
</span><span class="ln at-only-b"></span><span>}
</span></code></pre><p>So maybe all we have to do is to compile Stockfish and it will just work on Windows 98…?</p><nav class="toc" aria-labelledby="toc-label"><span id="toc-label">Table of contents</span><ol><li><a href="#naive-attempt">Naïve attempt: don't do anything, just try it!</a></li><li><a href="#rebuilding-winpthreads">Rebuilding winpthreads</a></li><li><a href="#deadlock-on-startup">Deadlock on startup</a></li><li><a href="#implementing-try-enter-critical-section">Implementing that one missing function ourselves</a></li><li><a href="#dynamic-dispatch">Dynamic dispatch</a></li><li><a href="#damn-it-stockfish">Damn it, Stockfish</a></li><li><a href="#it-finally-works">It finally works!</a></li></ol></nav><section id="naive-attempt"><h2><a class="section-link" href="#naive-attempt"><span>Naïve attempt: don't do anything, just try it!</span><span aria-hidden="true"> §</span></a></h2><p>Alas, as can be expected, it's not that easy. If we don't do anything apart from just compiling Stockfish as-is with a stock GCC + mingw-w64 toolchain, trying to run the resulting binary on Windows 98 will just give us errors about unresolved imports.</p><p>There are three symbols the binary requires that are not present under Windows 98, all imported from <code>kernel32.dll</code>: <code>AddVectoredExceptionHandler</code>, <code>RemoveVectoredExceptionHandler</code> and <code>GetTickCount64</code>. Looking for these identifiers in Stockfish source code reveals nothing, so where are they coming from?</p><p>Looking at the disassembly, all three of these functions are used inside the aforementioned <cite class="program-name">winpthreads</cite> library. Can we do anything about that?</p></section><section id="rebuilding-winpthreads"><h2><a class="section-link" href="#rebuilding-winpthreads"><span>Rebuilding winpthreads</span><span aria-hidden="true"> §</span></a></h2><p>None of those three functions are used for anything critical. The vectored exception handling APIs, introduced in Windows XP, are used only to allow threads to be named under a debugger. <code>GetTickCount64</code>, added in Vista, is used for internal time tracking, but there exists a fallback path for older systems in the source code. The obvious solution would be to just patch them out and rebuild <cite class="program-name">winpthreads</cite>:</p><pre class="code-block"><span class="language">Unified diff</span>
<code class="numbered"><span class="ln at-only-b"></span><span><span class="c-gh">diff --git a/mingw-w64-libraries/winpthreads/src/misc.c b/mingw-w64-libraries/winpthreads/src/misc.c</span>
</span><span class="ln at-only-b"></span><span><span class="c-gd">--- a/mingw-w64-libraries/winpthreads/src/misc.c</span>
</span><span class="ln at-only-b"></span><span><span class="c-gi">+++ b/mingw-w64-libraries/winpthreads/src/misc.c</span>
</span><span class="ln at-only-b"></span><span><span class="c-gu">@@ -55,7 +55,7 @@ unsigned long long _pthread_rel_time_in_ms(const struct timespec *ts)</span>
</span><span class="ln at-only-b"></span><span> static unsigned long long
</span><span class="ln at-only-b"></span><span> _pthread_get_tick_count (long long *frequency)
</span><span class="ln at-only-b"></span><span> {
</span><span class="ln at-only-b"></span><span><span class="c-gd">-#if defined (_WIN32_WINNT) &amp;&amp; (_WIN32_WINNT &gt;= _WIN32_WINNT_VISTA)</span>
</span><span class="ln at-only-b"></span><span><span class="c-gi">+#if 0 &amp;&amp; defined (_WIN32_WINNT) &amp;&amp; (_WIN32_WINNT &gt;= _WIN32_WINNT_VISTA)</span>
</span><span class="ln at-only-b"></span><span>   (void) frequency; /* unused */
</span><span class="ln at-only-b"></span><span>   return GetTickCount64 ();
</span><span class="ln at-only-b"></span><span> #else
</span><span class="ln at-only-b"></span><span><span class="c-gh">diff --git a/mingw-w64-libraries/winpthreads/src/thread.c b/mingw-w64-libraries/winpthreads/src/thread.c</span>
</span><span class="ln at-only-b"></span><span><span class="c-gd">--- a/mingw-w64-libraries/winpthreads/src/thread.c</span>
</span><span class="ln at-only-b"></span><span><span class="c-gi">+++ b/mingw-w64-libraries/winpthreads/src/thread.c</span>
</span><span class="ln at-only-b"></span><span><span class="c-gu">@@ -57,7 +57,7 @@ static pthread_t idListNextId = 0;</span>
</span><span class="ln at-only-b"></span><span> #if !defined(_MSC_VER)
</span><span class="ln at-only-b"></span><span> #define USE_VEH_FOR_MSC_SETTHREADNAME
</span><span class="ln at-only-b"></span><span> #endif
</span><span class="ln at-only-b"></span><span><span class="c-gd">-#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)</span>
</span><span class="ln at-only-b"></span><span><span class="c-gi">+#if 1 || !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)</span>
</span><span class="ln at-only-b"></span><span> /* forbidden RemoveVectoredExceptionHandler/AddVectoredExceptionHandler APIs */
</span><span class="ln at-only-b"></span><span> #undef USE_VEH_FOR_MSC_SETTHREADNAME
</span><span class="ln at-only-b"></span><span> #endif
</span><span class="ln at-only-b"></span><span><span class="c-gu">@@ -109,7 +109,7 @@ SetThreadName (DWORD dwThreadID, LPCSTR szThreadName)</span>
</span><span class="ln at-only-b"></span><span>    /* Without a debugger we *must* have an exception handler,
</span><span class="ln at-only-b"></span><span>     * otherwise raising an exception will crash the process.
</span><span class="ln at-only-b"></span><span>     */
</span><span class="ln at-only-b"></span><span><span class="c-gd">-#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)</span>
</span><span class="ln at-only-b"></span><span><span class="c-gi">+#if 0 &amp;&amp; WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)</span>
</span><span class="ln at-only-b"></span><span>    if ((!IsDebuggerPresent ()) &amp;&amp; (SetThreadName_VEH_handle == NULL))
</span><span class="ln at-only-b"></span><span> #else
</span><span class="ln at-only-b"></span><span>    if (!IsDebuggerPresent ())
</span></code></pre><p>After rebuilding <cite class="program-name">winpthreads</cite> and re-linking Stockfish, the resulting binary now launches under Windows 98!</p></section><section id="deadlock-on-startup"><h2><a class="section-link" href="#deadlock-on-startup"><span>Deadlock on startup</span><span aria-hidden="true"> §</span></a></h2><p>Yes, the binary <em>launches</em>, but it doesn't <em>work</em>. It prints the version banner, but then hangs forever. Damn.</p><p>There are actually two issues that cause the hang. One is relatively easy to fix: <cite class="program-name">winpthreads</cite> uses <code>GetHandleInformation</code> for testing if the Win32 object handles are valid. This function exists on Windows 98 for limited NT compatibility, but it doesn't actually do anything, always returning 0 and setting the last error code to <code>ERROR_CALL_NOT_IMPLEMENTED</code>. Since this is mostly a debugging feature, it can safely be removed with another trivial patch:</p><pre class="code-block"><span class="language">Unified diff</span>
<code class="numbered"><span class="ln at-only-b"></span><span><span class="c-gh">diff --git a/mingw-w64-libraries/winpthreads/src/misc.h b/mingw-w64-libraries/winpthreads/src/misc.h</span>
</span><span class="ln at-only-b"></span><span><span class="c-gd">--- a/mingw-w64-libraries/winpthreads/src/misc.h</span>
</span><span class="ln at-only-b"></span><span><span class="c-gi">+++ b/mingw-w64-libraries/winpthreads/src/misc.h</span>
</span><span class="ln at-only-b"></span><span><span class="c-gu">@@ -62,7 +62,7 @@ typedef long long LONGBAG;</span>
</span><span class="ln at-only-b"></span><span> typedef long LONGBAG;
</span><span class="ln at-only-b"></span><span> #endif
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span><span class="c-gd">-#if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)</span>
</span><span class="ln at-only-b"></span><span><span class="c-gi">+#if 1 || !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)</span>
</span><span class="ln at-only-b"></span><span> #undef GetHandleInformation
</span><span class="ln at-only-b"></span><span> #define GetHandleInformation(h,f)  (1)
</span><span class="ln at-only-b"></span><span> #endif
</span></code></pre><p>The other issue is <em>much</em> more severe: there is another function like <code>GetHandleInformation</code> that "exists" on Windows 98, but is not actually implemented and always returns with an error. It's <code>TryEnterCriticalSection</code>, used several times in the implementation of condition variables. The code is written under the assumption that <code>TryEnterCriticalSection</code> actually works as described: if the critical section is not currently locked, it expects the call to take ownership of the critical section and succeed, but on Windows 98, this will never happen.</p><aside role="note"><p>Critical sections are the Win32 name for regular user-mode <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutexes</a>. Win32 also offers kernel-mode mutexes, which are heavy and slow, as they require system calls for every operation, so they're usually only used for inter-process communication.</p></aside><p>It's not possible to work around that problem by patching away <code>TryEnterCriticalSection</code> calls without a significant re-architecture of <cite class="program-name">winpthreads</cite>'s condition variables. Clearly, a different approach is needed this time.</p></section><section id="implementing-try-enter-critical-section"><h2><a class="section-link" href="#implementing-try-enter-critical-section"><span>Implementing that one missing function ourselves</span><span aria-hidden="true"> §</span></a></h2><p><code>TryEnterCriticalSection</code> being present, but not actually implemented on Windows 98 is the only obstacle left, albeit a significant one. The algorithm itself is simple: find out where the atomic indicating whether the section is locked is, and use an operation like atomic compare-and-swap to change it, returning true if the section wasn't locked before. Unfortunately, the structure of critical sections is completely undocumented, and there aren't many good sources that are still alive on what critical sections looked like in that old operating system, so finding out where the atomic variable <em>is</em> requires some work.</p><p>From what I can gather from old debug symbols and looking at disassembly, the <code>CRITICAL_SECTION</code> structure looks similar to this in Windows 98:</p><pre class="code-block"><span class="language">C++</span>
<code class="numbered"><span class="ln at-only-b"></span><span><span class="c-k">struct</span> critical_section {
</span><span class="ln at-only-b"></span><span>    std::<span class="c-k">uint8_t</span> type; <span class="c-c">// Always 4.
</span></span><span class="ln at-only-b"></span><span>    <span class="c-k">struct</span> critical_section_impl* impl;
</span><span class="ln at-only-b"></span><span>    <span class="c-c">// Padding for NT compatibility, where the structure is completely
</span></span><span class="ln at-only-b"></span><span>    <span class="c-c">// different.
</span></span><span class="ln at-only-b"></span><span>    std::<span class="c-k">uint32_t</span> reserved[<span class="c-m">4</span>];
</span><span class="ln at-only-b"></span><span>};
</span><span class="ln at-only-b"></span><span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(critical_section) == <span class="c-m">24</span>);
</span></code></pre><p>That's not very useful, it's essentially just a pointer to something else. So what does <code>critical_section_impl</code> look like? That's where our atomic actually is, together with a recursion counter, current owner and some uninteresting to us stuff:</p><pre class="code-block"><span class="language">C++</span>
<code class="numbered"><span class="ln at-only-b"></span><span><span class="c-k">struct</span> critical_section_impl {
</span><span class="ln at-only-b"></span><span>    std::<span class="c-k">uint8_t</span> type;
</span><span class="ln at-only-b"></span><span>    <span class="c-k">int</span> recursion_count;
</span><span class="ln at-only-b"></span><span>    <span class="c-k">void</span>* owner_thread;
</span><span class="ln at-only-b"></span><span>    std::<span class="c-k">uint32_t</span> reserved;
</span><span class="ln at-only-b"></span><span>    std::atomic&lt;<span class="c-k">int</span>&gt; lock_count; <span class="c-c">// Starts at 1 when not owned, decreasing.
</span></span><span class="ln at-only-b"></span><span>    <span class="c-k">void</span>* internal_pointers[<span class="c-m">3</span>];
</span><span class="ln at-only-b"></span><span>};
</span><span class="ln at-only-b"></span><span><span class="c-k">static_assert</span>(<span class="c-k">sizeof</span>(critical_section_impl) == <span class="c-m">32</span>);
</span></code></pre><p>There is another complication waiting for us here: the owner thread is represented as a pointer to its TDBX, which is the <em>kernel-mode</em> data structure representing a thread, internal to <code>vwin32.vxd</code>, the process management part of the Windows 9x kernel.</p><p>Fortunately, the (undocumented) <a href="https://en.wikipedia.org/wiki/Win32_Thread_Information_Block">thread information block</a> does contain a pointer to the thread's TDBX. Unfortunately, its location varies between system versions: it's at offset <code>0x50</code> from the start of the TIB in Windows 95 (according to Windows 95 System Programming Secrets) and 98, but at offset <code>0x80</code> in Windows Me (according to KernelEx sources). While I don't care about Windows 95 at all, Windows Me would be nice to support if only because it's the successor of Windows 98.</p><p>With all that in mind, we can implement our version of <code>TryEnterCriticalSection</code> for Windows 98 and Me, using a C++ template to parameterize the code over the TDBX pointer offset:</p><pre class="code-block"><span class="language">C++</span>
<code class="numbered"><span class="ln at-only-b"></span><span><span class="c-k">constexpr</span> std::<span class="c-k">uint8_t</span> critical_section_type = <span class="c-m">4</span>;
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span><span class="c-k">template</span> &lt;<span class="c-k">unsigned</span> TdbxOffset&gt;
</span><span class="ln at-only-b"></span><span><span class="c-k">void</span>* get_current_tdbx()
</span><span class="ln at-only-b"></span><span>{
</span><span class="ln at-only-b"></span><span>    <span class="c-k">const</span> <span class="c-k">char</span>* tib;
</span><span class="ln at-only-b"></span><span>    <span class="c-k">asm</span>(<span class="c-s">"mov {%%fs:0x18, %0|%0, fs:[0x18]}"</span> : <span class="c-s">"=r"</span>(tib));
</span><span class="ln at-only-b"></span><span>    <span class="c-k">return</span> *<span class="c-k">reinterpret_cast</span>&lt;<span class="c-k">void</span>* <span class="c-k">const</span>*&gt;(tib + TdbxOffset);
</span><span class="ln at-only-b"></span><span>}
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span><span class="c-k">template</span> &lt;<span class="c-k">unsigned</span> TdbxOffset&gt;
</span><span class="ln at-only-b"></span><span><span class="c-k">bool</span> try_enter_9x_impl(critical_section_impl* cs)
</span><span class="ln at-only-b"></span><span>{
</span><span class="ln at-only-b"></span><span>    <span class="c-k">const</span> <span class="c-k">auto</span> current_tdbx = get_current_tdbx&lt;TdbxOffset&gt;();
</span><span class="ln at-only-b"></span><span>    <span class="c-k">int</span> actual_lock_count = <span class="c-m">1</span>;
</span><span class="ln at-only-b"></span><span>    <span class="c-k">if</span>(cs-&gt;lock_count.compare_exchange_strong(actual_lock_count, <span class="c-m">0</span>)) {
</span><span class="ln at-only-b"></span><span>        cs-&gt;owner_thread = current_tdbx;
</span><span class="ln at-only-b"></span><span>        ++cs-&gt;recursion_count;
</span><span class="ln at-only-b"></span><span>        <span class="c-k">return</span> true;
</span><span class="ln at-only-b"></span><span>    } <span class="c-k">else</span> <span class="c-k">if</span>(cs-&gt;owner_thread == current_tdbx) {
</span><span class="ln at-only-b"></span><span>        cs-&gt;lock_count.fetch_sub(<span class="c-m">1</span>, std::memory_order_relaxed);
</span><span class="ln at-only-b"></span><span>        ++cs-&gt;recursion_count;
</span><span class="ln at-only-b"></span><span>        <span class="c-k">return</span> true;
</span><span class="ln at-only-b"></span><span>    } <span class="c-k">else</span> {
</span><span class="ln at-only-b"></span><span>        <span class="c-k">return</span> false;
</span><span class="ln at-only-b"></span><span>    }
</span><span class="ln at-only-b"></span><span>}
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span><span class="c-k">template</span> &lt;<span class="c-k">unsigned</span> TdbxOffset&gt;
</span><span class="ln at-only-b"></span><span>[[gnu::stdcall]] <span class="c-k">int</span> try_enter_9x(CRITICAL_SECTION* cs)
</span><span class="ln at-only-b"></span><span>{
</span><span class="ln at-only-b"></span><span>    <span class="c-k">const</span> <span class="c-k">auto</span> actual = <span class="c-k">reinterpret_cast</span>&lt;critical_section*&gt;(cs);
</span><span class="ln at-only-b"></span><span>    <span class="c-k">if</span>(actual-&gt;type != critical_section_type) {
</span><span class="ln at-only-b"></span><span>        [[unlikely]] RaiseException(EXCEPTION_ACCESS_VIOLATION, <span class="c-m">0</span>, <span class="c-m">0</span>, <span class="c-m">0</span>);
</span><span class="ln at-only-b"></span><span>        <span class="c-k">return</span> <span class="c-m">0</span>;
</span><span class="ln at-only-b"></span><span>    }
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span>    <span class="c-k">return</span> try_enter_9x_impl&lt;TdbxOffset&gt;(actual-&gt;impl);
</span><span class="ln at-only-b"></span><span>}
</span></code></pre></section><section id="dynamic-dispatch"><h2><a class="section-link" href="#dynamic-dispatch"><span>Dynamic dispatch</span><span aria-hidden="true"> §</span></a></h2><p>We could implement <code>TryEnterCriticalSection</code> by just always calling <code>try_enter_9x</code>, but that would break compatibility with Windows NT. Having one binary that can run on anything from Windows 98 to Windows 10 is just cleaner in my opinion, so let's choose the implementation at runtime, based on the operating system version.</p><p>To do that, we can use the <code>GetVersion</code> Windows API function, which has the nice guarantee of returning a value with the highest bit clear if and only if the operating system is some version of Windows NT, together with the usual <code>LoadLibraryA</code> and <code>GetProcAddress</code> calls to retrieve the address of the actual <code>TryEnterCriticalSection</code> implementation on Windows NT:</p><pre class="code-block"><span class="language">C++</span>
<code class="numbered"><span class="ln at-only-b"></span><span><span class="c-k">constexpr</span> <span class="c-k">unsigned</span> tdbx_offset_98 = <span class="c-m">0x50</span>;
</span><span class="ln at-only-b"></span><span><span class="c-k">constexpr</span> <span class="c-k">unsigned</span> tdbx_offset_me = <span class="c-m">0x80</span>;
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span><span class="c-k">constexpr</span> std::<span class="c-k">uint32_t</span> windows_9x_mask = <span class="c-m">0x80000000</span>;
</span><span class="ln at-only-b"></span><span><span class="c-k">constexpr</span> std::<span class="c-k">uint32_t</span> windows_me_version = <span class="c-m">0xC0005A04</span>;
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span>[[gnu::stdcall]] <span class="c-k">int</span> try_enter_dispatch(CRITICAL_SECTION* cs);
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span><span class="c-k">using</span> try_enter_type = <span class="c-k">decltype</span>(&amp;TryEnterCriticalSection);
</span><span class="ln at-only-b"></span><span>std::atomic&lt;try_enter_type&gt; implementation = &amp;try_enter_dispatch;
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span>[[gnu::stdcall]] <span class="c-k">int</span> try_enter_dispatch(CRITICAL_SECTION* cs)
</span><span class="ln at-only-b"></span><span>{
</span><span class="ln at-only-b"></span><span>    <span class="c-k">const</span> <span class="c-k">auto</span> system_version = GetVersion();
</span><span class="ln at-only-b"></span><span>    <span class="c-k">if</span>((system_version &amp; windows_9x_mask) == <span class="c-m">0</span>) {
</span><span class="ln at-only-b"></span><span>        <span class="c-k">const</span> <span class="c-k">auto</span> kernel32 = LoadLibraryA(<span class="c-s">"kernel32.dll"</span>);
</span><span class="ln at-only-b"></span><span>        <span class="c-k">const</span> <span class="c-k">auto</span> impl = <span class="c-k">reinterpret_cast</span>&lt;try_enter_type&gt;(
</span><span class="ln at-only-b"></span><span>            GetProcAddress(kernel32, <span class="c-s">"TryEnterCriticalSection"</span>));
</span><span class="ln at-only-b"></span><span>        implementation.store(impl, std::memory_order_relaxed);
</span><span class="ln at-only-b"></span><span>    } <span class="c-k">else</span> {
</span><span class="ln at-only-b"></span><span>        <span class="c-k">const</span> <span class="c-k">auto</span> impl = system_version == windows_me_version
</span><span class="ln at-only-b"></span><span>            ? &amp;try_enter_9x&lt;tdbx_offset_me&gt;
</span><span class="ln at-only-b"></span><span>            : &amp;try_enter_9x&lt;tdbx_offset_98&gt;;
</span><span class="ln at-only-b"></span><span>        implementation.store(impl, std::memory_order_relaxed);
</span><span class="ln at-only-b"></span><span>    }
</span><span class="ln at-only-b"></span><span>    <span class="c-k">return</span> implementation.load(std::memory_order_relaxed)(cs);
</span><span class="ln at-only-b"></span><span>}
</span><span class="ln at-only-b"></span><span>
</span><span class="ln at-only-b"></span><span><span class="c-k">extern</span> <span class="c-s">"C"</span>
</span><span class="ln at-only-b"></span><span>[[gnu::stdcall]] <span class="c-k">int</span> TryEnterCriticalSection_compat(CRITICAL_SECTION* cs)
</span><span class="ln at-only-b"></span><span>{
</span><span class="ln at-only-b"></span><span>    <span class="c-k">return</span> implementation.load(std::memory_order_relaxed)(cs);
</span><span class="ln at-only-b"></span><span>}
</span></code></pre><p><a href="/static/try-enter-critsec-9x.cc">The complete, compilable source code</a> of the fallback implementation of <code>TryEnterCriticalSection</code> is available under <a href="https://creativecommons.org/publicdomain/zero/1.0/">the CC0 license</a>.</p><p>All that's left now is to force <cite class="program-name">winpthreads</cite> to use our function instead of the system one by adding a few lines to <code>misc.h</code> and rebuilding the <cite class="program-name">winpthreads</cite> static library: </p><pre class="code-block"><span class="language">C++</span>
<code class="numbered"><span class="ln at-only-b"></span><span class="c-c">#ifndef TryEnterCriticalSection
</span><span class="ln at-only-b"></span><span><span class="c-k">int</span> WINAPI TryEnterCriticalSection_compat(CRITICAL_SECTION* cs);
</span><span class="ln at-only-b"></span><span class="c-c">#define TryEnterCriticalSection TryEnterCriticalSection_compat
</span><span class="ln at-only-b"></span><span class="c-c">#endif
</span></code></pre><p>Now we can just build Stockfish using our modified <cite class="program-name">winpthreads</cite>, remembering to link our fallback implementation, and…</p></section><section id="damn-it-stockfish"><h2><a class="section-link" href="#damn-it-stockfish"><span>Damn it, Stockfish</span><span aria-hidden="true"> §</span></a></h2><p>When I first attempted this ordeal, at the beginning of September, that was indeed everything that's needed to get Stockfish running on Windows 98. A recent change to Stockfish broke it however: now the binary will fail to run, because the import <code>GetLargePageMinimum</code> is unresolved. Not a big deal, it's used in exactly one place in Stockfish code: large page allocation code. The call can be replaced with a constant 0 to allow Windows 98 to run it, at the cost of the binary no longer supporting large pages. A slight speed loss on modern versions of Windows, but the point here is to run it on Windows 98.</p><p>After this one last trivial change…</p></section><section id="it-finally-works"><h2><a class="section-link" href="#it-finally-works"><span>It finally works!</span><span aria-hidden="true"> §</span></a></h2><p>It really does! Of course, since it's just a chess <em>engine</em>, it's only a console program:</p><figure><figcaption>Stockfish running in a Windows 98 console window</figcaption><div class="holder"><img src="/static/stockfish-cmd.png" width="652" height="359" alt="A Windows 98 console window displaying a truncated list of Universal Chess Interface options supported by Stockfish and the information about the used compiler."></div></figure><p>Since it's just an engine, we should be able to use any Universal Chess Interface-capable graphical program with it, and indeed, the Arena chess interface version 1.1, from 2004, has no problems with using this build of Stockfish as an engine:</p><figure><figcaption>SOS 5 for Arena (white) playing against current Stockfish (black) under Arena 1.1, running on Windows 98</figcaption><div class="holder"><img src="/static/sos-vs-stockfish.png" width="1024" height="744" alt="Arena 1.1 running a match between SOS 5 playing white and current Stockfish playing black, with white to move. Stockfish has a material advantage of one pawn. Both engines agree that black is better."></div></figure><p>Now I can watch Stockfish demolish the old engines shipped with a 16-year-old chess program, running under a 22-year-old operating system, on 18-year-old hardware, in peace.</p></section></article></main><nav aria-label="Chronological, secondary"><ul id="order-nav"><li class="top"><a href="#skip-nav"><span aria-hidden="true">↑ </span>Top<span aria-hidden="true"> ↑</span></a></li><li class="prev"><a rel="prev" href="/is-x86-risc-internally.html"><span aria-hidden="true">← </span>Older</a></li><li><a href="/archives/">Blog archives</a></li><li class="next"><a rel="next" href="/blog-update.html">Newer<span aria-hidden="true"> →</span></a></li></ul></nav><footer><ul id="footer"><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019-2021 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>