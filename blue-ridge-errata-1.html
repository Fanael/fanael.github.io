<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Security-Policy" content="default-src 'self'"><meta name="generator" content="Some custom Common Lisp"><meta name="description" content="Explanation and solution of a serious Blue Ridge design problem involving root pointers during evacuation"><link rel="canonical" href="/blue-ridge-errata-1.html"><link rel="stylesheet" href="/static/theme.css"><link rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/"><title>Blue Ridge errata #1: root pointers during evacuation - Fanael's random ruminations</title></head><body><a id="skip-nav" href="#main">Skip to main content</a><header id="mainheader">Fanael's random ruminations</header><nav aria-label="Primary"><ul id="navmenu"><li><a href="/">Main page</a></li><li><a href="/archives/">Archives</a></li><li><a href="https://github.com/Fanael/fanael.github.io/">GitHub</a></li><li><a rel="author" href="/pages/about.html">About</a></li></ul></nav><main id="main"><article><header><h1><a class="section-header-link" href="#main">§</a>Blue Ridge errata #1: root pointers during evacuation</h1><p class="publishdate">Published on the <time datetime="2020-02-08">8th of February 2020</time></p><p class="article-topics">Topics: <a href="/archives/topic-garbage-collection.html">garbage-collection</a></p></header><p>While trying to implement concurrent evacuation I've found out that there is a serious problem with <a href="/incremental-low-pause-gc.html">my simple incremental low-pause garbage collector</a> design. Implementing the <a href="/incremental-low-pause-gc.html#phases">phase ordering</a> exactly as specified <strong>would corrupt the root set</strong>, resulting in not very fun to debug crashes, even with extensive heap verification and lots of assertions everywhere. Why? Let's go through the pertinent assumptions, and the way they interact, carefully, and find a solution.</p><nav class="toc" aria-labelledby="toc-label"><span id="toc-label">Table of contents</span><ol><li><a href="#what-goes-wrong">What goes wrong?</a></li><li><a href="#corruption-soup-ingredients">The ingredients of our corruption soup</a></li><li><a href="#just-reorder-phases">Easy, just reorder phases!</a></li><li><a href="#tradeoff">It's a tradeoff</a></li><li><a href="#phases-updated">Phase ordering, updated</a></li></ol></nav><section id="what-goes-wrong"><h2><a class="section-header-link" href="#what-goes-wrong">§</a>What goes wrong?</h2><p>This innocuous, perfectly reasonable code attempts to access from-space memory of an evacuated object:</p><pre class="codeblock" data-code-language="C++"><code>root_pointer&lt;widget&gt; blue_widget = get_widget(color::blue);
<span class="c-c">// Suppose our blue widget gets evacuated by incremental GC during this call,
</span><span class="c-c">// and evacuation hasn't completed yet, so the update roots phase hasn't run.
</span>prepare_for_frobbing();
<span class="c-c">// blue_widget now points to from-space memory, frobbing it won't affect
</span><span class="c-c">// the to-space copy!
</span><span class="c-c">// Or if the evacuation process poisons the from-space memory, frobbing it
</span><span class="c-c">// will crash.
</span>frob(blue_widget);
</code></pre></section><section id="corruption-soup-ingredients"><h2><a class="section-header-link" href="#corruption-soup-ingredients">§</a>The ingredients of our corruption soup</h2><p>There are several assumptions the original design makes that together cause the problem:</p><ul><li><b>Root pointers are always valid</b>, as far as the mutator is concerned. This makes accessing data through root pointers <em>fast</em>, because there is no barrier code to execute, it's just a regular memory access through a pointer.</li><li><b>Evacuation is concurrent</b>. Obviously, if it's not concurrent, the issue magically disappears, but Blue Ridge is a mostly concurrent collector, so evacuation better stay concurrent.</li><li><b>Objects directly pointed to by roots can move</b>. Treating all objects pointed to from the root set as pinned is not something I'd consider desirable, even if pinning in a regionalized collector can be easy and cheap compared to traditional collectors with unified heap.</li></ul><p>Clearly, something needs to change, but none of the apparent solutions sound satisfactory. Introducing a barrier to resolve the to-space address of a root pointer is too expensive — just think of a just-in-time compiled implementation that keeps some of the root pointers in CPU registers having to run a non-trivial chunk of code containing several conditionals every time it wants to access something, the overhead would be prohibitive. Stop-the-world evacuation is out of the question in a mostly-concurrent collector, and treating root set pointees as pinned is a hack. Situation appears bleak…</p></section><section id="just-reorder-phases"><h2><a class="section-header-link" href="#just-reorder-phases">§</a>Easy, just reorder phases!</h2><p>…except there is a way out: what if the update roots phase ran <em>before</em> concurrent evacuation, thus ensuring the mutator can never have from-space pointers in the root set (remember that the load reference barrier prevents the mutator from loading a from-space pointer from the heap <em>during</em> evacuation already)? It cannot <em>just</em> update the root pointers, because it doesn't know the to-space addresses of those objects yet, because evacuation hasn't started yet, so this phase has to evacuate those objects itself; we can now call this phase <b>evacuate roots</b>.</p></section><section id="tradeoff"><h2><a class="section-header-link" href="#tradeoff">§</a>It's a tradeoff</h2><p><a href="https://en.wikipedia.org/wiki/Food_Not_Bombs">There is such thing as a free lunch</a>, but this is not it, so naturally, there is a catch. Updating pointers is almost trivial: look at the pointee to see if it has a forwarding pointer, and change the pointer being updated to that value if it does. Evacuation is more involved, as it requires copying the object, so naturally, it is slower. Since this is a stop-the-world phase, the worst-case latency is going to rise. It's still affected only by the root set size, though, only the constant factor is larger, which is acceptable in my case, as this approach is much simpler than the alternatives listed above, relative simplicity being another important factor of the design after all.</p></section><section id="phases-updated"><h2><a class="section-header-link" href="#phases-updated">§</a>Phase ordering, updated</h2><p>For reference, the updated <a href="/incremental-low-pause-gc.html#phases">list of phases</a> is now as follows.</p><ol><li>Mark roots.</li><li>Incremental mark.</li><li>Remark roots.</li><li><b>Evacuate roots</b>, the subject of this post.</li><li>Incremental evacuation.</li><li>Incremental update references.</li><li>Cleanup.</li></ol></section></article></main><nav aria-label="Chronological, secondary"><ul id="prevnext"><li class="top"><a href="#">↑ Top ↑</a></li><li class="prev"><a rel="prev" href="/breaking-empty-base-optimization.html">← Older</a></li><li><a href="/archives/">Blog archives</a></li><li class="next"><a rel="next" href="/is-x86-risc-internally.html">Newer →</a></li></ul></nav><footer><ul id="footerstuff"><li>Powered by HTML &amp; CSS</li><li>Copyright © 2019-2020 Fanael Linithien</li><li>Licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a></li></ul></footer></body></html>